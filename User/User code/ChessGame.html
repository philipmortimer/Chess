<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>ChessGame.java</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<style type="text/css">
<!--
body {color: #000000; background-color: #ffffff; font-family: Monospaced}
pre {color: #000000; background-color: #ffffff; font-family: Monospaced}
table {color: #000000; background-color: #e9e8e2; font-family: Monospaced}
.string {color: #ce7b00}
.literal {color: #0000e6}
.comment {color: #969696}
.ST0 {color: #969696; font-family: Monospaced; font-weight: bold}
-->
</style>
</head>
<body>
<table width="100%"><tr><td align="center">C:\Users\mortimer\OneDrive - gowercollegeswansea.ac.uk\Documents\College\YEAR 12\COMPUTER SCIENCE\Books attempt\DataBase\PhilipM CS5 Software Development User System\src\philipm\cs5\software\development\user\system\ChessGame.java</td></tr></table>
<pre>
   1 <span class="comment">/*</span>
   2 <span class="comment"> * To change this license header, choose License Headers in Project Properties.</span>
   3 <span class="comment"> * To change this template file, choose Tools | Templates</span>
   4 <span class="comment"> * and open the template in the editor.</span>
   5 <span class="comment"> */</span>
   6 <span class="literal">package</span> philipm.cs5.software.development.user.system;
   7 
   8 <span class="literal">import</span> java.io.BufferedReader;
   9 <span class="literal">import</span> java.io.FileReader;
  10 <span class="literal">import</span> java.io.IOException;
  11 <span class="literal">import</span> java.util.ArrayList;
  12 <span class="literal">import</span> java.util.Collections;
  13 <span class="literal">import</span> java.util.Random;
  14 <span class="literal">import</span> javax.swing.JOptionPane;
  15 
  16 <span class="comment">/**</span>
  17 <span class="comment"> * </span><span class="ST0">This</span> <span class="ST0">class</span> <span class="ST0">stores</span> <span class="ST0">the</span> <span class="ST0">chess</span> <span class="ST0">game</span><span class="ST0"> (</span><span class="ST0">i</span><span class="ST0">.</span><span class="ST0">e</span><span class="ST0">.</span> <span class="comment">all</span> <span class="comment">board</span> <span class="comment">states</span><span class="comment">)</span><span class="comment">.</span> <span class="comment">It</span> <span class="comment">also</span> <span class="comment">handles</span> <span class="comment">getting</span> <span class="comment">any</span> <span class="comment">potential</span> <span class="comment">computer</span> <span class="comment">moves</span><span class="comment">.</span>
  18 <span class="comment"> * </span><span class="ST0">@author</span> <span class="comment">mortimer</span>
  19  <span class="comment">*/</span>
  20 <span class="literal">public</span> <span class="literal">class</span> ChessGame {
  21     <span class="literal">private</span> ChessBoardState [] states;<span class="comment">//stores all board states so far</span>
  22     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> BLACK_MULT=-1;<span class="literal">final</span> <span class="literal">int</span> WHITE_MULT=1;
  23     <span class="comment">//these values are used for level 2 evalaution</span>
  24     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> VALUE_OF_PAWN=1;<span class="comment">//stores the relative value of the pawn</span>
  25     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> VALUE_OF_ROOK=5;<span class="comment">//stores relative value of rook</span>
  26     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> VALUE_OF_BISHOP=3;<span class="comment">//stores relative value of bishop</span>
  27     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> VALUE_OF_KNIGHT=3;<span class="comment">//stores relative value of knight</span>
  28     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> VALUE_OF_QUEEN=9;<span class="comment">//stores relative value of queen</span>
  29     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> VALUE_OF_KING=600000;<span class="comment">//stores the value of the king - which is an arbitarily high value</span>
  30     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> DRAW_VALUE=0;<span class="comment">//stores the value assigned to a draw</span>
  31     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> WHITE_WIN_VALUE=(Integer.MAX_VALUE-1)-1;
  32     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> BLACK_WIN_VALUE=(Integer.MAX_VALUE*-1)+1;
  33     <span class="comment">//stores the relative positional value for pieces</span>
  34     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]PAWN_POSITIONAL_WHITE={{0,0,0,0,0,0,0,0},{50,50,50,50,50,50,50,50},{10,10,20,30,30,20,10,10},{5,5,10,25,25,10,5,5},{0,0,0,20,20,0,0,0},{5,-5,-10,0,0,-10,-5,5},{5,10,10,-20,-20,10,10,5},{0,0,0,0,0,0,0,0}};
  35     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]PAWN_POSITIONAL_BLACK={{0,0,0,0,0,0,0,0},{-5,-10,-10,20,20,-10,-10,-5},{-5,5,10,0,0,10,5,-5},{0,0,0,-20,-20,0,0,0},{-5,-5,-10,-25,-25,-10,-5,-5},{-10,-10,-20,-30,-30,-20,-10,-10},{-50,-50,-50,-50,-50,-50,-50,-50},{0,0,0,0,0,0,0,0}};
  36     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]KNIGHT_POSITIONAL_WHITE={{-50,-40,-30,-30,-30,-30,-40,-50},{-40,-20,0,0,0,0,-20,-40},{-30,0,10,15,15,10,0,-30},{-30,5,15,20,20,15,5,-30},{-30,0,15,20,20,15,0,-30},{-30,5,10,15,15,10,5,-30},{-40,-20,0,5,5,0,-20,-40},{-50,-40,-30,-30,-30,-30,-40,-50}};
  37     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]KNIGHT_POSITIONAL_BLACK={{50,40,30,30,30,30,40,50},{40,20,0,-5,-5,0,20,40},{30,-5,-10,-15,-15,-10,-5,30},{30,0,-15,-20,-20,-15,0,30},{30,-5,-15,-20,-20,-15,-5,30},{30,0,-10,-15,-15,-10,0,30},{40,20,0,0,0,0,20,40},{50,40,30,30,30,30,40,50}};
  38     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]QUEEN_POSITIONAL_WHITE={{-20,-10,-10,-5,-5,-10,-10,-20},{-10,0,0,0,0,0,0,-10},{-10,0,5,5,5,5,0,-10},{-5,0,5,5,5,5,0,-5},{0,0,5,5,5,5,0,-5},{-10,5,5,5,5,5,0,-10},{-10,0,5,0,0,0,0,-10},{-20,-10,-10,-5,-5,-10,-10,-20}};
  39     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]QUEEN_POSITIONAL_BLACK={{20,10,10,5,5,10,10,20},{10,0,0,0,0,-5,0,10},{10,0,-5,-5,-5,-5,-5,10},{5,0,-5,-5,-5,-5,0,0},{5,0,-5,-5,-5,-5,0,5},{10,0,-5,-5,-5,-5,0,10},{10,0,0,0,0,0,0,10},{20,10,10,5,5,10,10,20}};
  40     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]BISHOP_POSITIONAL_WHITE={{-20,-10,-10,-10,-10,-10,-10,-20},{-10,0,0,0,0,0,0,-10},{-10,0,5,10,10,5,0,-10},{-10,5,5,10,10,5,5,-10},{-10,0,10,10,10,10,0,-10},{-10,10,10,10,10,10,10,-10},{-10,5,0,0,0,0,5,-10},{-20,-10,-10,-10,-10,-10,-10,-20}};
  41     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]BISHOP_POSITIONAL_BLACK={{20,10,10,10,10,10,10,20},{10,-5,0,0,0,0,-5,10},{10,-10,-10,-10,-10,-10,-10,10},{10,0,-10,-10,-10,-10,0,10},{10,-5,-5,-10,-10,-5,-5,10},{10,0,-5,-10,-10,-5,0,10},{10,0,0,0,0,0,0,10},{20,10,10,10,10,10,10,20}};
  42     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]ROOK_POSITIONAL_WHITE={{0,0,0,0,0,0,0,0},{5,10,10,10,10,10,10,5},{-5,0,0,0,0,0,0,-5},{-5,0,0,0,0,0,0,-5},{-5,0,0,0,0,0,0,-5},{-5,0,0,0,0,0,0,-5},{-5,0,0,0,0,0,0,-5},{0,0,0,5,5,0,0,0}};
  43     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]ROOK_POSITIONAL_BLACK={{0,0,0,-5,-5,0,0,0},{5,0,0,0,0,0,0,5},{5,0,0,0,0,0,0,5},{5,0,0,0,0,0,0,5},{5,0,0,0,0,0,0,5},{5,0,0,0,0,0,0,5},{-5,-10,-10,-10,-10,-10,-10,-5},{0,0,0,0,0,0,0,0}};
  44     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]KING_POSITIONAL_WHITE_MID={{-30,-40,-40,-50,-50,-40,-40,-30},{-30,-40,-40,-50,-50,-40,-40,-30},{-30,-40,-40,-50,-50,-40,-40,-30},{-30,-40,-40,-50,-50,-40,-40,-30},{-20,-30,-30,-40,-40,-30,-30,-20},{-10,-20,-20,-20,-20,-20,-20,-10},{20,20,0,0,0,0,20,20},{20,30,10,0,0,10,30,20}};
  45     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]KING_POSITIONAL_BLACK_MID={{-20,-30,-10,0,0,-10,-30,-20},{-20,-20,0,0,0,0,-20,-20},{10,20,20,20,20,20,20,10},{20,30,30,40,40,30,30,20},{30,40,40,50,50,40,40,30},{30,40,40,50,50,40,40,30},{30,40,40,50,50,40,40,30},{30,40,40,50,50,40,40,30}};
  46     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]KING_POSITIONAL_WHITE_END={{-50,-40,-30,-20,-20,-30,-40,-50},{-30,-20,-10,0,0,-10,-20,-30},{-30,-10,20,30,30,20,-10,-30},{-30,-10,30,40,40,30,-10,-30},{-30,-10,30,40,40,30,-10,-30},{-30,-10,20,30,30,20,-10,-30},{-30,-30,0,0,0,0,-30,-30},{-50,-30,-30,-30,-30,-30,-30,-50}};
  47     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span>[][]KING_POSITIONAL_BLACK_END={{50,30,30,30,30,30,30,50},{30,30,0,0,0,0,30,30},{30,10,-20,-30,-30,-20,10,30},{30,10,-30,-40,-40,-30,10,30},{30,10,-30,-40,-40,-30,10,30},{30,10,-20,-30,-30,-20,10,30},{30,20,10,0,0,10,20,30},{50,40,30,20,20,30,40,50}};
  48     <span class="comment">//stores the rough value of each of the chess pieces in centipawns</span>
  49     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> PAWN=100;
  50     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> KNIGHT=320;
  51     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> BISHOP=330;
  52     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> ROOK =500;
  53     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> KING=20000;
  54     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">final</span> <span class="literal">int</span> QUEEN=900;
  55     <span class="literal">private</span> ChessNeuralNetwork net;<span class="comment">//stores a neural network trained to evalaute board positions</span>
  56     <span class="literal">private</span>  <span class="literal">final</span> String[][]OPENING_BOOK;<span class="comment">//stores the opening book - small number of moves made by chess grandmasters early in a game</span>
  57     <span class="comment">/**</span>
  58 <span class="comment">     * </span><span class="ST0">Creates</span> <span class="ST0">a</span> <span class="ST0">chess</span> <span class="ST0">game</span> <span class="ST0">object</span> <span class="ST0">storing</span> <span class="ST0">all</span> <span class="ST0">the</span> <span class="ST0">states</span> <span class="ST0">played</span> <span class="ST0">so</span> <span class="ST0">far</span>
  59 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">statesSoFar</span> <span class="comment">All</span> <span class="comment">chess</span> <span class="comment">board</span> <span class="comment">states</span> <span class="comment">that</span> <span class="comment">have</span> <span class="comment">already</span> <span class="comment">occurred</span>
  60 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">loadNeuralNet</span> <span class="comment">Whether</span> <span class="comment">a</span> <span class="comment">neural</span> <span class="comment">network</span> <span class="comment">should</span> <span class="comment">be</span> <span class="comment">loaded</span> <span class="comment">when</span> <span class="comment">initialising</span> <span class="comment">the</span> <span class="comment">chess</span> <span class="comment">game</span>
  61      <span class="comment">*/</span>
  62     <span class="literal">public</span> ChessGame(ChessBoardState[]statesSoFar,<span class="literal">boolean</span> loadNeuralNet){
  63         OPENING_BOOK=getOpeningBook();<span class="comment">//loads the opening book</span>
  64         states =statesSoFar;<span class="comment">//stores all board states so far in the game</span>
  65         <span class="literal">if</span>(loadNeuralNet){
  66             <span class="comment">//loads the neural network to evaluate the board states</span>
  67             <span class="literal">try</span>{
  68                 net= <span class="literal">new</span> ChessNeuralNetwork(<span class="literal">new</span> <span class="literal">int</span>[]{<span class="comment">/*777,610,300,200,100,2*/</span>777,300,200,100,2});
  69             }<span class="literal">catch</span>(IOException e){
  70                 net=<span class="literal">null</span>;
  71                 JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;</span><span class="string">An unexpected error occured when loading the neural network. Setting the computer to level 4 insetad. Error details: </span><span class="string">&quot;</span>+e,<span class="string">&quot;</span><span class="string">Error</span><span class="string">&quot;</span>,JOptionPane.OK_OPTION);
  72             }
  73         }
  74         
  75     }
  76     <span class="comment">/**</span>
  77 <span class="comment">     * </span><span class="ST0">Reads</span> <span class="ST0">and</span> <span class="ST0">loads</span> <span class="ST0">opening</span> <span class="ST0">book</span>
  78 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">The</span> <span class="comment">opening</span> <span class="comment">book</span>
  79      <span class="comment">*/</span>
  80     <span class="literal">private</span> <span class="literal">static</span> String[][] getOpeningBook(){
  81         String arr[][]=<span class="literal">new</span> String[11318][2];<span class="comment">//stores the data set of opening moves. It is stored in the form of boardState(t) -&gt; boardState(t+1)</span>
  82         <span class="literal">try</span>{
  83             FileReader read =<span class="literal">new</span> FileReader(<span class="string">&quot;</span><span class="string">openingMoves.txt</span><span class="string">&quot;</span>);<span class="comment">//reads all opening moves from the text file that stores them</span>
  84             BufferedReader buffRead = <span class="literal">new</span> BufferedReader(read);
  85             <span class="literal">int</span> i=0;
  86             String lineRead;String line[];
  87             <span class="literal">while</span>((lineRead=buffRead.readLine())!=<span class="literal">null</span>){
  88                 line=lineRead.split(<span class="string">&quot;</span><span class="string">,</span><span class="string">&quot;</span>);
  89                 arr[i][0]=line[0];arr[i][1]=line[1];
  90                 i++;
  91             }
  92             buffRead.close();
  93             read.close();
  94         }<span class="literal">catch</span>(IOException e){
  95             System.out.println(<span class="string">&quot;</span><span class="string">error with opening book: </span><span class="string">&quot;</span>+e);
  96         }
  97         <span class="literal">return</span> arr;
  98     }
  99     <span class="comment">/**</span>
 100 <span class="comment">     * </span><span class="ST0">Gets</span> <span class="ST0">the</span> <span class="ST0">computer</span> <span class="ST0">move</span> <span class="ST0">given</span> <span class="ST0">the</span> <span class="ST0">computer</span> <span class="ST0">level</span> <span class="ST0">as</span> <span class="ST0">input</span><span class="ST0">.</span>
 101 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">computerLevel</span> <span class="comment">An</span> <span class="comment">integer</span> <span class="comment">between</span><span class="comment"> 1 </span><span class="comment">and</span><span class="comment"> 5 (</span><span class="comment">both</span> <span class="comment">inclusive</span><span class="comment">)</span><span class="comment">.</span>
 102 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span> <span class="comment">representing</span> <span class="comment">the</span> <span class="comment">move</span> <span class="comment">that</span> <span class="comment">has</span> <span class="comment">been</span> <span class="comment">executed</span>
 103      <span class="comment">*/</span>
 104     <span class="literal">public</span>  ChessBoardState getComputerMove(<span class="literal">int</span> computerLevel){
 105         <span class="literal">if</span>(getCurrentState().FULL_MOVE_NUMBER&lt;=10 &amp;&amp; computerLevel!=5){<span class="comment">//plays a move out of the opening book if possible</span>
 106             String fen =getCurrentState().getFenString();<span class="comment">//gets the fen string of the current board state</span>
 107             String fenData[]=fen.split(<span class="string">&quot;</span> <span class="string">&quot;</span>);
 108             <span class="literal">int</span> i=Search.searchForRecordIndex(OPENING_BOOK, fen);<span class="comment">//searches for the current board state</span>
 109             <span class="literal">if</span>(i!=Search.INDEX_NOT_FOUND){
 110                 <span class="literal">int</span> start=i;<span class="literal">int</span> end=i;
 111                 <span class="comment">//finds the lower and upper bound of it</span>
 112                 <span class="literal">for</span>(;start&gt;0;start--){
 113                     <span class="literal">if</span>(OPENING_BOOK[start][0].equals(fen)==<span class="literal">false</span>){
 114                         start++;<span class="literal">break</span>;
 115                     }
 116                 }
 117                 <span class="literal">for</span>(;end&lt;OPENING_BOOK.length;end++){
 118                     <span class="literal">if</span>(OPENING_BOOK[end][0].equals(fen)==<span class="literal">false</span>){
 119                         end--;
 120                         <span class="literal">break</span>;
 121                     }
 122                 }
 123                 <span class="comment">//returns random board state from possible options</span>
 124                 Random rnd = <span class="literal">new</span> Random();
 125                 <span class="literal">if</span>(getCurrentState().IS_BLACK_TURN_TO_PLAY_NEXT){
 126                     fen=<span class="string">&quot;</span> <span class="string">&quot;</span>+String.valueOf(getCurrentState().FULL_MOVE_NUMBER+1);
 127                 }<span class="literal">else</span>{
 128                     fen=<span class="string">&quot;</span> <span class="string">&quot;</span>+String.valueOf(getCurrentState().FULL_MOVE_NUMBER);
 129                 } 
 130                 <span class="literal">try</span>{
 131                     Thread.sleep(500);<span class="comment">//doesn&#39;t make the move instantly</span>
 132                 }<span class="literal">catch</span>(InterruptedException e){
 133                     
 134                 }
 135                 <span class="literal">return</span> <span class="literal">new</span> ChessBoardState(OPENING_BOOK[rnd.nextInt((end-start)+1)+start][1]+fen);<span class="comment">//creates a new chess board state and returns it</span>
 136             }
 137         }
 138         <span class="comment">//gets the computer move depedning on the computer level selected</span>
 139         <span class="literal">switch</span> (computerLevel) {
 140             <span class="literal">case</span> 1:
 141                 <span class="comment">//gets a random move and plays it</span>
 142                 ArrayList&lt;ChessBoardState&gt;possibleStates=getAllLegalBoardsFromState(<span class="literal">this</span>.getCurrentState());
 143                 Random rnd = <span class="literal">new</span> Random();
 144                 <span class="literal">try</span>{
 145                     Thread.sleep(500);<span class="comment">//doesn&#39;t make the move instantly</span>
 146                 }<span class="literal">catch</span>(InterruptedException e){
 147                     
 148                 }
 149                 <span class="literal">return</span> (possibleStates.get(rnd.nextInt(possibleStates.size())));<span class="comment">//returns the random move</span>
 150             <span class="literal">case</span> 3:
 151                 <span class="comment">//implements a depth limited minimax algorithm looking at the value of pieces and summing them</span>
 152                 <span class="literal">return</span> getComputerMoveMinimax(getCurrentState(), computerLevel, 3);
 153             <span class="literal">case</span> 2:
 154                 <span class="comment">//uses minimax algorithm alongside a neural network I have trained</span>
 155                 <span class="literal">if</span>(net==<span class="literal">null</span>){<span class="comment">// if a network error occurs then the move for the level four computer is retrieved instead</span>
 156                     <span class="literal">return</span> getComputerMove(4);
 157                 }
 158                 <span class="literal">return</span> getComputerMoveMinimax(getCurrentState(), computerLevel, 3);
 159             <span class="literal">case</span> 4:
 160                 <span class="comment">//uses an advanced evalaution function</span>
 161                 <span class="literal">return</span> getComputerMoveMinimax(getCurrentState(), computerLevel, 3);
 162             <span class="literal">default</span>:<span class="comment">//computer level five</span>
 163                 <span class="comment">//uses StockFish to get a move;</span>
 164                 <span class="literal">try</span>{
 165                     StockFish stock = <span class="literal">new</span> StockFish();<span class="comment">//loads stockfish</span>
 166                     ChessBoardState state =<span class="literal">new</span> ChessBoardState(stock.getStockFishMove(getCurrentState().getFenString()));<span class="comment">//fetches the appropriate board state</span>
 167                     stock.exit();<span class="comment">//exits stock fish</span>
 168                     <span class="literal">return</span> state;
 169                 }<span class="literal">catch</span>(IOException e){
 170                     JOptionPane.showMessageDialog(<span class="literal">null</span>, <span class="string">&quot;</span><span class="string">Failed to load stockfish (the level five computer). Hence, a move is being played by the level four computer. This could be because your system is not a windows 64 bit device.</span><span class="string">&quot;</span>,<span class="string">&quot;</span><span class="string">Error</span><span class="string">&quot;</span>,JOptionPane.OK_OPTION);
 171                 }
 172                 <span class="literal">return</span> getComputerMove(4);
 173         }
 174     }
 175     <span class="comment">/**</span>
 176 <span class="comment">     * </span><span class="ST0">Implements</span> <span class="ST0">the</span> <span class="ST0">minimax</span> <span class="ST0">algorithm</span> <span class="ST0">and</span> <span class="ST0">returns</span> <span class="ST0">the</span> <span class="ST0">board</span> <span class="ST0">state</span> <span class="ST0">that</span> <span class="ST0">is</span> <span class="ST0">to</span> <span class="ST0">be</span> <span class="ST0">played</span><span class="ST0">.</span>
 177 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">currentState</span> <span class="comment">The</span> <span class="comment">starting</span> <span class="comment">board</span> <span class="comment">state</span>
 178 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">computerLevel</span> <span class="comment">The</span> <span class="comment">computer</span> <span class="comment">level</span><span class="comment">.</span> <span class="comment">Levels</span> <span class="comment">from</span><span class="comment"> 2-5 </span><span class="comment">are</span> <span class="comment">valid</span><span class="comment">.</span>
 179 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">searchDepth</span> <span class="comment">The</span> <span class="comment">search</span> <span class="comment">depth</span> <span class="comment">for</span> <span class="comment">the</span> <span class="comment">minimax</span> <span class="comment">algorithm</span><span class="comment">.</span>
 180 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">The</span> <span class="comment">chess</span> <span class="comment">board</span>
 181      <span class="comment">*/</span>
 182     <span class="literal">private</span>  ChessBoardState getComputerMoveMinimax(ChessBoardState currentState, <span class="literal">int</span> computerLevel,<span class="literal">int</span> searchDepth){
 183         ArrayList&lt;ChessBoardState&gt;allStates = getAllLegalBoardsFromState(currentState);<span class="comment">//gets all legal board states from the current board</span>
 184         <span class="literal">int</span> bestIndex=0;<span class="comment">//stores the index of the state that is best</span>
 185         <span class="literal">int</span> currentBest;
 186         <span class="literal">int</span> valOfMove;
 187         <span class="literal">if</span>(currentState.IS_BLACK_TURN_TO_PLAY_NEXT){
 188             currentBest=Integer.MAX_VALUE;
 189         }<span class="literal">else</span>{
 190             currentBest=Integer.MAX_VALUE*-1;
 191             Collections.reverse(allStates);
 192         }
 193         <span class="comment">//loops through all board states and finds the board state which is best for the current player</span>
 194         <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;allStates.size();i++){
 195             <span class="literal">if</span>(currentState.IS_BLACK_TURN_TO_PLAY_NEXT){<span class="comment">//if it&#39;s black&#39;s turn, they are aiming to minimise the final value</span>
 196                 valOfMove=maxTurnMinimax(allStates.get(i), 1, -1*Integer.MAX_VALUE, Integer.MAX_VALUE, searchDepth, computerLevel);<span class="comment">//gets value of board state</span>
 197                 <span class="literal">if</span>(valOfMove&lt;=currentBest){
 198                     currentBest=valOfMove;
 199                     bestIndex=i;
 200                 }
 201             }<span class="literal">else</span>{<span class="comment">//white aims to maximise the board value</span>
 202                 valOfMove=minTurnMinimax(allStates.get(i), 1, -1*Integer.MAX_VALUE, Integer.MAX_VALUE, searchDepth, computerLevel);
 203                 <span class="literal">if</span>(valOfMove&gt;=currentBest){
 204                     currentBest=valOfMove;
 205                     bestIndex=i;
 206                 }
 207             }
 208         }
 209         <span class="comment">//returns the best move calculated</span>
 210         <span class="literal">return</span> allStates.get(bestIndex);
 211     }
 212     <span class="comment">/**</span>
 213 <span class="comment">     * </span><span class="ST0">Implements</span> <span class="ST0">a</span> <span class="ST0">recursive</span> <span class="ST0">depth</span> <span class="ST0">limited</span> <span class="ST0">alpha</span><span class="ST0">-</span><span class="ST0">beta</span> <span class="ST0">pruned</span> <span class="ST0">minimax</span> <span class="ST0">algorithm</span> <span class="ST0">to</span> <span class="ST0">evaluate</span> <span class="ST0">which</span> <span class="ST0">move</span> <span class="ST0">the</span> <span class="ST0">computer</span> <span class="ST0">must</span> <span class="ST0">make</span> <span class="ST0">next</span><span class="ST0">.</span> <span class="comment">This</span> <span class="comment">is</span> <span class="comment">called</span> <span class="comment">by</span> <span class="comment">the</span> <span class="comment">maximising</span> <span class="comment">player</span>
 214 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">state</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span> <span class="comment">to</span> <span class="comment">evaluate</span>
 215 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">depth</span> <span class="comment">The</span> <span class="comment">current</span> <span class="comment">search</span> <span class="comment">depth</span>
 216 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">alpha</span> <span class="comment">The</span> <span class="comment">value</span> <span class="comment">of</span> <span class="comment">alpha</span>
 217 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">beta</span> <span class="comment">The</span> <span class="comment">value</span> <span class="comment">of</span> <span class="comment">beta</span>
 218 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">maxSearchDepth</span> <span class="comment">The</span> <span class="comment">maximum</span> <span class="comment">search</span> <span class="comment">depth</span>
 219 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">computerLevel</span> <span class="comment">The</span> <span class="comment">computer</span> <span class="comment">level</span>
 220 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">value</span>
 221      <span class="comment">*/</span>
 222     <span class="literal">private</span>  <span class="literal">int</span> maxTurnMinimax(ChessBoardState state, <span class="literal">int</span> depth, <span class="literal">int</span> alpha, <span class="literal">int</span> beta, <span class="literal">int</span> maxSearchDepth, <span class="literal">int</span> computerLevel){
 223         ArrayList&lt;ChessBoardState&gt;possibleStates = getAllLegalBoardsFromState(state);<span class="comment">//gets all possible board from all current board</span>
 224         Collections.reverse(possibleStates);<span class="comment">//reverses the board states as move ordering is employed to maximise the number of nodes pruned. As the moves are odered from lowest points to highest, the move order needs to be reversed</span>
 225         <span class="literal">if</span>(possibleStates.isEmpty()){<span class="comment">//if board is in a terminal state, it returns the appropraite value</span>
 226             <span class="literal">if</span>(state.getIsDraw()){
 227                 <span class="literal">return</span> DRAW_VALUE;
 228             }
 229             <span class="literal">if</span>(state.IS_BLACK_TURN_TO_PLAY_NEXT){
 230                 <span class="literal">return</span> WHITE_WIN_VALUE;
 231             }<span class="literal">else</span>{
 232                 <span class="literal">return</span> BLACK_WIN_VALUE;
 233             }
 234         }
 235         <span class="literal">if</span>(depth==maxSearchDepth){<span class="comment">//if the maximum search depth has been reached, the appropriate evaluation is called</span>
 236             <span class="literal">return</span> getBoardValue(state,computerLevel);
 237         }
 238         <span class="comment">//if the search depth and terminal staten haven&#39;t been reached, the minimax process continues</span>
 239         <span class="literal">int</span> max=-1*Integer.MAX_VALUE;<span class="comment">//stores the max value</span>
 240         <span class="literal">int</span> currentMoveValue;<span class="comment">//stores the value of a single move</span>
 241         <span class="literal">for</span> (ChessBoardState possibleState : possibleStates) {<span class="comment">//loops through all possible board states</span>
 242             currentMoveValue= minTurnMinimax(possibleState,depth+1,alpha,beta,maxSearchDepth,computerLevel);
 243             <span class="literal">if</span>(currentMoveValue&gt;max){<span class="comment">//sets max value</span>
 244                 max=currentMoveValue;
 245             }
 246             <span class="comment">//implements alpha beta pruning</span>
 247             <span class="literal">if</span>(currentMoveValue&gt;=beta){
 248                 <span class="literal">return</span> max;
 249             }
 250             <span class="literal">if</span>(currentMoveValue&gt;alpha){
 251                 alpha =currentMoveValue;
 252             }
 253         }
 254         <span class="comment">//returns the value of the board state</span>
 255         <span class="literal">return</span> max;
 256     }
 257     <span class="comment">/**</span>
 258 <span class="comment">     * </span><span class="ST0">Implements</span> <span class="ST0">a</span> <span class="ST0">recursive</span> <span class="ST0">depth</span> <span class="ST0">limited</span> <span class="ST0">alpha</span><span class="ST0">-</span><span class="ST0">beta</span> <span class="ST0">pruned</span> <span class="ST0">minimax</span> <span class="ST0">algorithm</span> <span class="ST0">to</span> <span class="ST0">evaluate</span> <span class="ST0">which</span> <span class="ST0">move</span> <span class="ST0">the</span> <span class="ST0">computer</span> <span class="ST0">must</span> <span class="ST0">make</span> <span class="ST0">next</span><span class="ST0">.</span> <span class="comment">This</span> <span class="comment">is</span> <span class="comment">called</span> <span class="comment">by</span> <span class="comment">the</span> <span class="comment">minimising</span> <span class="comment">player</span>
 259 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">state</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span> <span class="comment">to</span> <span class="comment">evaluate</span>
 260 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">depth</span> <span class="comment">The</span> <span class="comment">current</span> <span class="comment">search</span> <span class="comment">depth</span>
 261 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">alpha</span> <span class="comment">The</span> <span class="comment">value</span> <span class="comment">of</span> <span class="comment">alpha</span>
 262 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">beta</span> <span class="comment">The</span> <span class="comment">value</span> <span class="comment">of</span> <span class="comment">beta</span>
 263 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">maxSearchDepth</span> <span class="comment">The</span> <span class="comment">maximum</span> <span class="comment">search</span> <span class="comment">depth</span>
 264 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">computerLevel</span> <span class="comment">The</span> <span class="comment">computer</span> <span class="comment">level</span>
 265 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">value</span>
 266      <span class="comment">*/</span>
 267     <span class="literal">private</span>  <span class="literal">int</span> minTurnMinimax(ChessBoardState state, <span class="literal">int</span> depth, <span class="literal">int</span> alpha, <span class="literal">int</span> beta, <span class="literal">int</span> maxSearchDepth, <span class="literal">int</span> computerLevel){
 268         ArrayList&lt;ChessBoardState&gt;possibleStates =getAllLegalBoardsFromState(state);<span class="comment">//gets all possible board from all current board</span>
 269         <span class="literal">if</span>(possibleStates.isEmpty()){<span class="comment">//if board is in a terminal state, it returns the appropraite value</span>
 270             <span class="literal">if</span>(state.getIsDraw()){
 271                 <span class="literal">return</span> DRAW_VALUE;
 272             }
 273             <span class="literal">if</span>(state.IS_BLACK_TURN_TO_PLAY_NEXT){
 274                 <span class="literal">return</span> WHITE_WIN_VALUE;
 275             }<span class="literal">else</span>{
 276                 <span class="literal">return</span> BLACK_WIN_VALUE;
 277             }
 278         }
 279         <span class="literal">if</span>(depth==maxSearchDepth){<span class="comment">//if the maximum search depth has been reached, the appropriate evaluation is called</span>
 280             <span class="literal">return</span> getBoardValue(state, computerLevel);
 281         }
 282         <span class="literal">int</span> min=Integer.MAX_VALUE;<span class="comment">//stores the minimum value</span>
 283         <span class="literal">int</span> currentMoveValue;<span class="comment">//stores the value of a single move</span>
 284         <span class="literal">for</span> (ChessBoardState possibleState : possibleStates) {<span class="comment">//loops through all possible board states</span>
 285             currentMoveValue= maxTurnMinimax(possibleState,depth+1,alpha,beta,maxSearchDepth,computerLevel);
 286             <span class="literal">if</span>(currentMoveValue&lt;min){<span class="comment">//sets min value</span>
 287                 min=currentMoveValue;
 288             }
 289             <span class="comment">//implements alpha beta pruning</span>
 290             <span class="literal">if</span>(currentMoveValue&lt;=alpha){
 291                 <span class="literal">return</span> min;
 292             }
 293             <span class="literal">if</span>(currentMoveValue&lt;beta){
 294                 beta =currentMoveValue;
 295             }
 296         }
 297         <span class="comment">//returns value of board state</span>
 298         <span class="literal">return</span> min;       
 299     }
 300     <span class="comment">/**</span>
 301 <span class="comment">     * </span><span class="ST0">Gets</span> <span class="ST0">the</span> <span class="ST0">value</span> <span class="ST0">of</span> <span class="ST0">a</span> <span class="ST0">non</span> <span class="ST0">terminal</span> <span class="ST0">board</span> <span class="ST0">state</span> <span class="ST0">using</span> <span class="ST0">an</span> <span class="ST0">appropriate</span> <span class="ST0">heuristic</span>
 302 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">state</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span>
 303 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">computerLevel</span> <span class="comment">The</span> <span class="comment">computer</span> <span class="comment">level</span>
 304 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">The</span> <span class="comment">value</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">board</span>
 305      <span class="comment">*/</span>
 306     <span class="literal">private</span> <span class="literal">int</span> getBoardValue(ChessBoardState state, <span class="literal">int</span> computerLevel){
 307         <span class="literal">int</span> boardValue=0;<span class="comment">//stores the board value</span>
 308         <span class="literal">switch</span>(computerLevel){
 309             <span class="literal">case</span> 3:
 310                 <span class="comment">//sums the value of the pieces on the board to calculate a board value</span>
 311                 <span class="literal">for</span>(<span class="literal">int</span> y=0;y&lt;8;y++){
 312                     <span class="literal">for</span>(<span class="literal">int</span> x=0;x&lt;8;x++){
 313                         <span class="literal">switch</span> (state.BOARD[y][x]) {
 314                             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 315                                 boardValue=boardValue+(VALUE_OF_PAWN*BLACK_MULT);
 316                                 <span class="literal">break</span>;
 317                             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 318                                 boardValue=boardValue+(VALUE_OF_KNIGHT*BLACK_MULT);
 319                                 <span class="literal">break</span>;
 320                             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 321                                 boardValue=boardValue+(VALUE_OF_BISHOP*BLACK_MULT);
 322                                 <span class="literal">break</span>;
 323                             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 324                                 boardValue=boardValue+(VALUE_OF_QUEEN*BLACK_MULT);
 325                                 <span class="literal">break</span>;
 326                             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 327                                 boardValue=boardValue+(VALUE_OF_ROOK*BLACK_MULT);
 328                                 <span class="literal">break</span>;
 329                             <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 330                                 boardValue=boardValue+(VALUE_OF_KING*BLACK_MULT);
 331                                 <span class="literal">break</span>;
 332                             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 333                                 boardValue=boardValue+(VALUE_OF_PAWN*WHITE_MULT);
 334                                 <span class="literal">break</span>;
 335                             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 336                                 boardValue=boardValue+(VALUE_OF_KNIGHT*WHITE_MULT);
 337                                 <span class="literal">break</span>;
 338                             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 339                                 boardValue=boardValue+(WHITE_MULT*VALUE_OF_BISHOP);
 340                                 <span class="literal">break</span>;
 341                             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 342                                 boardValue=boardValue+(WHITE_MULT*VALUE_OF_QUEEN);
 343                                 <span class="literal">break</span>;
 344                             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 345                                 boardValue = boardValue+(WHITE_MULT*VALUE_OF_ROOK);
 346                                 <span class="literal">break</span>;
 347                             <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 348                                 boardValue=boardValue+(WHITE_MULT*VALUE_OF_KING);
 349                                 <span class="literal">break</span>;
 350                             <span class="literal">default</span>:
 351                                 <span class="literal">break</span>;
 352                         }
 353                     }
 354                 }
 355                 <span class="literal">break</span>;
 356             <span class="literal">case</span> 5:
 357                 <span class="comment">//this evaluation is used as sometimes users may not be able to use stockfish.</span>
 358                 <span class="comment">//stores various variables to determine whether board is in endgame or not</span>
 359                 <span class="comment">//evaluation is based heavily on https://www.chessprogramming.org/Simplified_Evaluation_Function</span>
 360                 <span class="literal">int</span> []coordBlackKing=<span class="literal">new</span> <span class="literal">int</span>[2];<span class="literal">int</span>[]coordWhiteKing=<span class="literal">new</span> <span class="literal">int</span>[2];
 361                 <span class="literal">int</span> noOfBlackMinorPieces=0;<span class="literal">int</span> noOfWhiteMinorPieces=0;
 362                 <span class="literal">int</span> noOfPiecesBlack=0;<span class="literal">int</span> noOfPiecesWhite=0;
 363                 <span class="literal">boolean</span> blackHasQueen=<span class="literal">false</span>;<span class="literal">boolean</span> whiteHasQueen=<span class="literal">false</span>;
 364                 <span class="literal">for</span>(<span class="literal">int</span> y=0;y&lt;8;y++){
 365                     <span class="literal">for</span>(<span class="literal">int</span> x=0;x&lt;8;x++){
 366                         <span class="literal">switch</span> (state.BOARD[y][x]) {
 367                             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 368                                 boardValue=boardValue+(PAWN*BLACK_MULT)+PAWN_POSITIONAL_BLACK[y][x];
 369                                 noOfPiecesBlack++;
 370                                 <span class="literal">break</span>;
 371                             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 372                                 boardValue=boardValue+(KNIGHT*BLACK_MULT)+KNIGHT_POSITIONAL_BLACK[y][x];
 373                                 noOfBlackMinorPieces++;
 374                                 <span class="literal">break</span>;
 375                             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 376                                 noOfBlackMinorPieces++;
 377                                 boardValue=boardValue+(BISHOP*BLACK_MULT)+BISHOP_POSITIONAL_BLACK[y][x];
 378                                 <span class="literal">break</span>;
 379                             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 380                                 blackHasQueen=<span class="literal">true</span>;
 381                                 boardValue=boardValue+(QUEEN*BLACK_MULT)+QUEEN_POSITIONAL_BLACK[y][x];
 382                                 <span class="literal">break</span>;
 383                             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 384                                 noOfPiecesBlack++;
 385                                 boardValue=boardValue+(ROOK*BLACK_MULT)+ROOK_POSITIONAL_BLACK[y][x];
 386                                 <span class="literal">break</span>;
 387                             <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 388                                 boardValue=boardValue+(KING*BLACK_MULT);
 389                                 coordBlackKing[0]=y;coordBlackKing[1]=x;
 390                                 <span class="literal">break</span>;
 391                             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 392                                 noOfPiecesWhite++;
 393                                 boardValue=boardValue+(PAWN*WHITE_MULT)+PAWN_POSITIONAL_WHITE[y][x];
 394                                 <span class="literal">break</span>;
 395                             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 396                                 noOfWhiteMinorPieces++;
 397                                 boardValue=boardValue+(KNIGHT*WHITE_MULT)+KNIGHT_POSITIONAL_WHITE[y][x];
 398                                 <span class="literal">break</span>;
 399                             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 400                                 noOfWhiteMinorPieces++;
 401                                 boardValue=boardValue+(WHITE_MULT*BISHOP)+BISHOP_POSITIONAL_WHITE[y][x];
 402                                 <span class="literal">break</span>;
 403                             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 404                                 whiteHasQueen=<span class="literal">true</span>;
 405                                 boardValue=boardValue+(WHITE_MULT*QUEEN)+QUEEN_POSITIONAL_WHITE[y][x];
 406                                 <span class="literal">break</span>;
 407                             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 408                                 noOfPiecesWhite++;
 409                                 boardValue = boardValue+(WHITE_MULT*ROOK)+ROOK_POSITIONAL_WHITE[y][x];
 410                                 <span class="literal">break</span>;
 411                             <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 412                                 boardValue=boardValue+(WHITE_MULT*KING);
 413                                 coordWhiteKing[0]=y;coordWhiteKing[1]=x;
 414                                 <span class="literal">break</span>;
 415                             <span class="literal">default</span>:
 416                                 <span class="literal">break</span>;
 417                         }
 418                     }
 419                 }
 420                 <span class="literal">if</span>(((noOfPiecesBlack==0&amp;&amp;noOfBlackMinorPieces&lt;=1)||!blackHasQueen)&amp;&amp;((noOfPiecesWhite==0&amp;&amp;noOfWhiteMinorPieces&lt;=1)||!whiteHasQueen)){<span class="comment">//this statement is true if the game is in an endgame state</span>
 421                     boardValue=boardValue+KING_POSITIONAL_BLACK_END[coordBlackKing[0]][coordBlackKing[1]]+KING_POSITIONAL_WHITE_END[coordWhiteKing[0]][coordWhiteKing[1]];
 422                 }<span class="literal">else</span>{
 423                     boardValue = boardValue+KING_POSITIONAL_BLACK_MID[coordBlackKing[0]][coordBlackKing[1]]+KING_POSITIONAL_WHITE_MID[coordWhiteKing[0]][coordWhiteKing[1]];
 424                 }
 425                 <span class="literal">break</span>;
 426             <span class="literal">case</span> 4:
 427                 <span class="comment">//calculates the board value by summing the value of the pieces and their relative positional values</span>
 428                 <span class="comment">//stores various variables to determine whether board is in endgame or not</span>
 429                 <span class="comment">//evaluation is based heavily on https://www.chessprogramming.org/Simplified_Evaluation_Function</span>
 430                 coordBlackKing=<span class="literal">new</span> <span class="literal">int</span>[2];coordWhiteKing=<span class="literal">new</span> <span class="literal">int</span>[2];
 431                 noOfBlackMinorPieces=0;noOfWhiteMinorPieces=0;
 432                 noOfPiecesBlack=0;noOfPiecesWhite=0;
 433                 blackHasQueen=<span class="literal">false</span>;whiteHasQueen=<span class="literal">false</span>;
 434                 <span class="literal">for</span>(<span class="literal">int</span> y=0;y&lt;8;y++){
 435                     <span class="literal">for</span>(<span class="literal">int</span> x=0;x&lt;8;x++){
 436                         <span class="literal">switch</span> (state.BOARD[y][x]) {
 437                             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 438                                 boardValue=boardValue+(PAWN*BLACK_MULT)+PAWN_POSITIONAL_BLACK[y][x];
 439                                 noOfPiecesBlack++;
 440                                 <span class="literal">break</span>;
 441                             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 442                                 boardValue=boardValue+(KNIGHT*BLACK_MULT)+KNIGHT_POSITIONAL_BLACK[y][x];
 443                                 noOfBlackMinorPieces++;
 444                                 <span class="literal">break</span>;
 445                             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 446                                 noOfBlackMinorPieces++;
 447                                 boardValue=boardValue+(BISHOP*BLACK_MULT)+BISHOP_POSITIONAL_BLACK[y][x];
 448                                 <span class="literal">break</span>;
 449                             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 450                                 blackHasQueen=<span class="literal">true</span>;
 451                                 boardValue=boardValue+(QUEEN*BLACK_MULT)+QUEEN_POSITIONAL_BLACK[y][x];
 452                                 <span class="literal">break</span>;
 453                             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 454                                 noOfPiecesBlack++;
 455                                 boardValue=boardValue+(ROOK*BLACK_MULT)+ROOK_POSITIONAL_BLACK[y][x];
 456                                 <span class="literal">break</span>;
 457                             <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 458                                 boardValue=boardValue+(KING*BLACK_MULT);
 459                                 coordBlackKing[0]=y;coordBlackKing[1]=x;
 460                                 <span class="literal">break</span>;
 461                             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 462                                 noOfPiecesWhite++;
 463                                 boardValue=boardValue+(PAWN*WHITE_MULT)+PAWN_POSITIONAL_WHITE[y][x];
 464                                 <span class="literal">break</span>;
 465                             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 466                                 noOfWhiteMinorPieces++;
 467                                 boardValue=boardValue+(KNIGHT*WHITE_MULT)+KNIGHT_POSITIONAL_WHITE[y][x];
 468                                 <span class="literal">break</span>;
 469                             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 470                                 noOfWhiteMinorPieces++;
 471                                 boardValue=boardValue+(WHITE_MULT*BISHOP)+BISHOP_POSITIONAL_WHITE[y][x];
 472                                 <span class="literal">break</span>;
 473                             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 474                                 whiteHasQueen=<span class="literal">true</span>;
 475                                 boardValue=boardValue+(WHITE_MULT*QUEEN)+QUEEN_POSITIONAL_WHITE[y][x];
 476                                 <span class="literal">break</span>;
 477                             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 478                                 noOfPiecesWhite++;
 479                                 boardValue = boardValue+(WHITE_MULT*ROOK)+ROOK_POSITIONAL_WHITE[y][x];
 480                                 <span class="literal">break</span>;
 481                             <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 482                                 boardValue=boardValue+(WHITE_MULT*KING);
 483                                 coordWhiteKing[0]=y;coordWhiteKing[1]=x;
 484                                 <span class="literal">break</span>;
 485                             <span class="literal">default</span>:
 486                                 <span class="literal">break</span>;
 487                         }
 488                     }
 489                 }
 490                 <span class="literal">if</span>(((noOfPiecesBlack==0&amp;&amp;noOfBlackMinorPieces&lt;=1)||!blackHasQueen)&amp;&amp;((noOfPiecesWhite==0&amp;&amp;noOfWhiteMinorPieces&lt;=1)||!whiteHasQueen)){<span class="comment">//this statement is true if the game is in an endgame state</span>
 491                     boardValue=boardValue+KING_POSITIONAL_BLACK_END[coordBlackKing[0]][coordBlackKing[1]]+KING_POSITIONAL_WHITE_END[coordWhiteKing[0]][coordWhiteKing[1]];
 492                 }<span class="literal">else</span>{
 493                     boardValue = boardValue+KING_POSITIONAL_BLACK_MID[coordBlackKing[0]][coordBlackKing[1]]+KING_POSITIONAL_WHITE_MID[coordWhiteKing[0]][coordWhiteKing[1]];
 494                 }
 495                 <span class="literal">break</span>;
 496             <span class="literal">case</span> 2:
 497                 <span class="comment">//feeds the board through a neural network to get the board value</span>
 498                 <span class="literal">double</span> ret[]=net.feedThroughNet(state.getNeuralNetInput());
 499                 boardValue = (<span class="literal">int</span>)(Math.round((ret[0]-ret[1])*(Integer.MAX_VALUE-10)));
 500                 <span class="literal">break</span>;
 501         }
 502         
 503         <span class="literal">return</span> boardValue;
 504     }
 505     <span class="comment">/**</span>
 506 <span class="comment">     * </span><span class="ST0">Gets</span> <span class="ST0">the</span> <span class="ST0">number</span> <span class="ST0">of</span> <span class="ST0">states</span> <span class="ST0">in</span> <span class="ST0">the</span> <span class="ST0">current</span> <span class="ST0">game</span>
 507 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">The</span> <span class="comment">number</span> <span class="comment">of</span> <span class="comment">states</span>
 508      <span class="comment">*/</span>
 509     <span class="literal">public</span> <span class="literal">int</span> getLengthOfStatesFoFar(){
 510         <span class="literal">return</span> states.length;
 511     }
 512     <span class="comment">/**</span>
 513 <span class="comment">     * </span><span class="ST0">Returns</span> <span class="ST0">the</span> <span class="ST0">state</span> <span class="ST0">stored</span> <span class="ST0">at</span> <span class="ST0">the</span> <span class="ST0">specified</span> <span class="ST0">index</span> <span class="ST0">in</span> <span class="ST0">the</span> <span class="ST0">array</span> <span class="ST0">of</span> <span class="ST0">all</span> <span class="ST0">states</span><span class="ST0">.</span>
 514 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">element</span> <span class="comment">The</span> <span class="comment">index</span>
 515 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">The</span> <span class="comment">state</span>
 516      <span class="comment">*/</span>
 517     <span class="literal">public</span> ChessBoardState getState(<span class="literal">int</span> element){
 518         <span class="literal">return</span> <span class="literal">this</span>.states[element];
 519     }
 520     <span class="comment">/**</span>
 521 <span class="comment">     * </span><span class="ST0">Adds</span> <span class="ST0">board</span> <span class="ST0">state</span> <span class="ST0">to</span> <span class="ST0">game</span><span class="ST0">.</span>
 522 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">state</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span>
 523      <span class="comment">*/</span>
 524     <span class="literal">public</span> <span class="literal">void</span> addState(ChessBoardState state){
 525         ChessBoardState[]statesNew = <span class="literal">new</span> ChessBoardState[states.length+1];
 526         statesNew[statesNew.length-1]=state;
 527         <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;statesNew.length-1;i++){
 528             statesNew[i]=states[i];
 529         }
 530         states = statesNew;
 531     }
 532     <span class="comment">/**</span>
 533 <span class="comment">     * </span><span class="ST0">Returns</span> <span class="ST0">all</span> <span class="ST0">boards</span> <span class="ST0">that</span> <span class="ST0">have</span> <span class="ST0">been</span> <span class="ST0">played</span> <span class="ST0">so</span> <span class="ST0">far</span>
 534 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">All</span> <span class="comment">chess</span> <span class="comment">board</span> <span class="comment">states</span> <span class="comment">as</span> <span class="comment">an</span> <span class="comment">array</span><span class="comment">.</span> <span class="comment">Note</span> <span class="comment">this</span> <span class="comment">array</span> <span class="comment">is</span> <span class="comment">not</span> <span class="comment">a</span> <span class="comment">copy</span><span class="comment">, </span><span class="comment">so</span> <span class="comment">states</span> <span class="comment">should</span> <span class="comment">not</span> <span class="comment">be</span> <span class="comment">written</span> <span class="comment">to</span> <span class="comment">unless</span> <span class="comment">appropriate</span><span class="comment">.</span>
 535      <span class="comment">*/</span>
 536     <span class="literal">public</span> ChessBoardState[]getAllStates(){
 537         <span class="literal">return</span> <span class="literal">this</span>.states;
 538     }
 539     <span class="comment">/**</span>
 540 <span class="comment">     * </span><span class="ST0">Updates</span> <span class="ST0">copy</span> <span class="ST0">of</span> <span class="ST0">castling</span> <span class="ST0">rights</span> <span class="ST0">if</span> <span class="ST0">move</span> <span class="ST0">is</span> <span class="ST0">made</span> <span class="ST0">for</span> <span class="ST0">that</span> <span class="ST0">square</span><span class="ST0">.</span> <span class="comment">This</span> <span class="comment">is</span> <span class="comment">used</span> <span class="comment">to</span> <span class="comment">ensure</span> <span class="comment">that</span> <span class="comment">castle</span> <span class="comment">rights</span> <span class="comment">reflect</span> <span class="comment">a</span> <span class="comment">potential</span> <span class="comment">rook</span> <span class="comment">capture</span><span class="comment">.</span>
 541 <span class="comment">     * </span><span class="comment">If</span> <span class="comment">the</span> <span class="comment">y</span> <span class="comment">and</span> <span class="comment">x</span> <span class="comment">coordinate</span> <span class="comment">match</span> <span class="comment">the</span> <span class="comment">starting</span> <span class="comment">position</span> <span class="comment">of</span> <span class="comment">any</span> <span class="comment">rook</span><span class="comment">, </span><span class="comment">the</span> <span class="comment">castling</span> <span class="comment">option</span> <span class="comment">for</span> <span class="comment">that</span> <span class="comment">rook</span> <span class="comment">is</span> <span class="comment">set</span> <span class="comment">to</span> <span class="comment">false</span><span class="comment">.</span>
 542 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">yCoord</span> <span class="comment">The</span> <span class="comment">y</span> <span class="comment">coordinate</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">move</span>
 543 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">xCoord</span> <span class="comment">The</span> <span class="comment">x</span> <span class="comment">coordinate</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">move</span>
 544 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">copyOfCastlingRights</span> <span class="comment">A</span> <span class="comment">copy</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">castling</span> <span class="comment">rights</span><span class="comment">.</span> <span class="comment">This</span> <span class="comment">array</span> <span class="comment">will</span> <span class="comment">be</span> <span class="comment">manipulated</span><span class="comment">.</span>
 545      <span class="comment">*/</span>
 546     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">void</span> getCastlingRightsAfterCapture(<span class="literal">int</span> yCoord, <span class="literal">int</span> xCoord,<span class="literal">boolean</span> copyOfCastlingRights[]){
 547         <span class="literal">if</span>(yCoord==0&amp;&amp;xCoord==0){<span class="comment">//castle used for black queenside</span>
 548             copyOfCastlingRights[3]=<span class="literal">false</span>;
 549         }<span class="literal">else</span> <span class="literal">if</span>(yCoord==0&amp;&amp;xCoord==7){<span class="comment">//castle used for black kingside</span>
 550             copyOfCastlingRights[2]=<span class="literal">false</span>;
 551         }<span class="literal">else</span> <span class="literal">if</span>(yCoord==7&amp;&amp; xCoord==0){<span class="comment">//white queenside</span>
 552             copyOfCastlingRights[1]=<span class="literal">false</span>;
 553         }<span class="literal">else</span> <span class="literal">if</span>(yCoord==7&amp;&amp;xCoord==7){<span class="comment">//white kingside</span>
 554             copyOfCastlingRights[0]=<span class="literal">false</span>;
 555         }
 556     }
 557     <span class="comment">/**</span>
 558 <span class="comment">     * </span><span class="ST0">Gets</span> <span class="ST0">all</span> <span class="ST0">legal</span> <span class="ST0">board</span> <span class="ST0">states</span> <span class="ST0">from</span> <span class="ST0">the</span> <span class="ST0">chosen</span> <span class="ST0">position</span><span class="ST0">.</span> <span class="comment">Note</span><span class="comment">: </span><span class="comment">normally</span> <span class="comment">only</span> <span class="comment">one</span> <span class="comment">legal</span> <span class="comment">board</span> <span class="comment">state</span> <span class="comment">will</span> <span class="comment">be</span> <span class="comment">returned</span> <span class="comment">but</span>
 559 <span class="comment">     * </span><span class="comment">pawn</span> <span class="comment">promotion</span> <span class="comment">will</span> <span class="comment">return</span> <span class="comment">four</span> <span class="comment">states</span><span class="comment"> (</span><span class="comment">one</span> <span class="comment">for</span> <span class="comment">each</span> <span class="comment">possible</span> <span class="comment">choice</span> <span class="comment">of</span> <span class="comment">piece</span><span class="comment">)</span><span class="comment">.</span> <span class="comment">DOES</span> <span class="comment">NOT</span> <span class="comment">handle</span><span class="comment"> 50 </span><span class="comment">move</span> <span class="comment">rule</span>
 560 <span class="comment">     * </span><span class="comment">or</span> <span class="comment">other</span> <span class="comment">draw</span><span class="comment"> / </span><span class="comment">win</span><span class="comment"> /</span><span class="comment">loss</span> <span class="comment">conditions</span> <span class="comment">for</span> <span class="comment">current</span> <span class="comment">board</span><span class="comment">, </span><span class="comment">these</span> <span class="comment">must</span> <span class="comment">be</span> <span class="comment">handled</span> <span class="comment">elsewhere</span> <span class="comment">where</span> <span class="comment">appropriate</span><span class="comment">.</span><span class="comment">Note</span> <span class="comment">moves</span> <span class="comment">input</span> <span class="comment">must</span> <span class="comment">be</span> <span class="comment">legal</span>
 561 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">yStart</span> <span class="comment">The</span> <span class="comment">y</span> <span class="comment">coordinate</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">piece</span>
 562 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">xStart</span> <span class="comment">The</span> <span class="comment">x</span> <span class="comment">coordinate</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">piece</span>
 563 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">yFinal</span> <span class="comment">The</span> <span class="comment">y</span> <span class="comment">coordinate</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">move</span>
 564 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">xFinal</span> <span class="comment">The</span> <span class="comment">x</span> <span class="comment">coordinate</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">move</span>
 565 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">state</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span> <span class="comment">to</span> <span class="comment">analyse</span>
 566 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">All</span> <span class="comment">possible</span> <span class="comment">states</span><span class="comment">.</span> <span class="comment">If</span> <span class="comment">no</span> <span class="comment">states</span> <span class="comment">exist</span><span class="comment">, </span><span class="comment">an</span> <span class="comment">array</span> <span class="comment">of</span> <span class="comment">length</span><span class="comment"> 0 </span><span class="comment">is</span> <span class="comment">returned</span>
 567      <span class="comment">*/</span>
 568     <span class="literal">public</span> <span class="literal">static</span>  ArrayList&lt;ChessBoardState&gt; getAllLegalBoardsFromMove(<span class="literal">int</span> yStart,<span class="literal">int</span> xStart, <span class="literal">int</span> yFinal,<span class="literal">int</span> xFinal,ChessBoardState state){
 569         <span class="literal">int</span>[][]boardNew=state.getCopyOfBoard();<span class="comment">//stores the new board</span>
 570         <span class="literal">boolean</span> []castlingRights=state.getCopyOfCastlingRights();<span class="comment">//stores the new castling rights</span>
 571         ArrayList&lt;ChessBoardState&gt; legalBoard=<span class="literal">new</span> ArrayList&lt;&gt;(1);
 572         <span class="literal">int</span>[]enPassantSquare;<span class="comment">//stores the en passsant square</span>
 573         <span class="literal">int</span> halfMove=state.HALF_MOVE_CLOCK;<span class="comment">//stores the number of half moves;</span>
 574         <span class="literal">int</span> fullMoveNo=state.FULL_MOVE_NUMBER;<span class="comment">//stores the number of moves made by black</span>
 575         <span class="literal">switch</span> (state.BOARD[yStart][xStart]) {
 576             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 577                 legalBoard=<span class="literal">new</span> ArrayList&lt;&gt;(5);
 578                 fullMoveNo++;<span class="comment">//increments moves as black has moved</span>
 579                 halfMove=0;<span class="comment">//as pawn advance resets half move clock, half move will always be at 0 after a pawn move</span>
 580                 <span class="comment">//checks to see if pawn has moved two forward (and updates en passant rights accoridngly)</span>
 581                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];
 582                 <span class="literal">if</span>(yFinal == yStart+2){
 583                     enPassantSquare =<span class="literal">new</span> <span class="literal">int</span>[2];enPassantSquare[0]=yStart+1;enPassantSquare[1]=xStart;
 584                 }
 585                 getCastlingRightsAfterCapture(yFinal, xFinal, castlingRights);<span class="comment">//updates castling rights where appropriate</span>
 586                 <span class="comment">//processes pawn move</span>
 587                 <span class="comment">//processes possible pawn promotion</span>
 588                 boardNew[yStart][xStart]=ChessBoardState.EMPTY_VALUE;
 589                 <span class="literal">if</span>(yFinal==7){<span class="comment">//can create four possible boards</span>
 590                     <span class="comment">//creates queen board</span>
 591                     boardNew[7][xFinal]=ChessBoardState.QUEEN_VALUE*ChessBoardState.BLACK_MULTIPLIER;
 592                     legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights, !state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));
 593                     <span class="comment">//handles bishop</span>
 594                     boardNew[7][xFinal]=ChessBoardState.ROOK_VALUE*ChessBoardState.BLACK_MULTIPLIER;
 595                     legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights, !state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));
 596                     <span class="comment">//handles knight</span>
 597                     boardNew[7][xFinal]=ChessBoardState.BISHOP_VALUE*ChessBoardState.BLACK_MULTIPLIER;
 598                     legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights, !state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));
 599                     <span class="comment">//handles rook</span>
 600                     boardNew[7][xFinal]=ChessBoardState.KNIGHT_VALUE*ChessBoardState.BLACK_MULTIPLIER;
 601                     legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights, !state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));
 602                     <span class="literal">return</span> legalBoard;<span class="comment">//returns states</span>
 603                 }
 604                 boardNew[yFinal][xFinal]=ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER;
 605                 <span class="literal">if</span>(state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT.length==2){<span class="comment">//checks for en passant capture</span>
 606                     <span class="literal">if</span>(yFinal==state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[0]&amp;&amp;xFinal==state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[1]){
 607                         boardNew[yStart][xFinal]=ChessBoardState.EMPTY_VALUE;<span class="comment">//captures pawn via en passant</span>
 608                     }
 609                 }
 610                 legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));
 611                 <span class="literal">return</span> legalBoard;<span class="comment">//returns move</span>
 612             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 613                 getCastlingRightsAfterCapture(yFinal, xFinal, castlingRights);<span class="comment">//updates castling rights where appropriate</span>
 614                 fullMoveNo++;<span class="comment">//increments moves as black has moved</span>
 615                 <span class="comment">//simply replaces moves knight to square</span>
 616                 boardNew[yStart][xStart]=ChessBoardState.EMPTY_VALUE;boardNew[yFinal][xFinal]=ChessBoardState.KNIGHT_VALUE*ChessBoardState.BLACK_MULTIPLIER;
 617                 <span class="comment">//checks to see if a capture has been made</span>
 618                 <span class="literal">if</span>(state.BOARD[yFinal][xFinal]!=ChessBoardState.EMPTY_VALUE){
 619                     halfMove=0;
 620                 }<span class="literal">else</span>{
 621                     halfMove++;
 622                 }
 623                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 624                 legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));<span class="comment">//returns move</span>
 625                 <span class="literal">return</span> legalBoard;
 626             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 627                 getCastlingRightsAfterCapture(yFinal, xFinal, castlingRights);<span class="comment">//updates castling rights where appropriate</span>
 628                 fullMoveNo++;<span class="comment">//increments moves as black has moved</span>
 629                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 630                 <span class="comment">//simply replaces moves bishop to square</span>
 631                 boardNew[yStart][xStart]=ChessBoardState.EMPTY_VALUE;boardNew[yFinal][xFinal]=ChessBoardState.BISHOP_VALUE*ChessBoardState.BLACK_MULTIPLIER;
 632                 <span class="comment">//checks to see if a capture has been made</span>
 633                 <span class="literal">if</span>(state.BOARD[yFinal][xFinal]!=ChessBoardState.EMPTY_VALUE){
 634                     halfMove=0;
 635                 }<span class="literal">else</span>{
 636                     halfMove++;
 637                 }
 638                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 639                 legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));<span class="comment">//returns move</span>
 640                 <span class="literal">return</span> legalBoard;
 641             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 642                 fullMoveNo++;<span class="comment">//increments moves as black has moved</span>
 643                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 644                 <span class="comment">//simply replaces moves rook to square</span>
 645                 boardNew[yStart][xStart]=ChessBoardState.EMPTY_VALUE;boardNew[yFinal][xFinal]=ChessBoardState.ROOK_VALUE*ChessBoardState.BLACK_MULTIPLIER;
 646                 <span class="comment">//checks to see if a capture has been made</span>
 647                 <span class="literal">if</span>(state.BOARD[yFinal][xFinal]!=ChessBoardState.EMPTY_VALUE){
 648                     halfMove=0;
 649                 }<span class="literal">else</span>{
 650                     halfMove++;
 651                 }
 652                 <span class="comment">//updates castling rights if appropriate</span>
 653                 <span class="literal">if</span>(yStart==0){
 654                     <span class="literal">if</span>(xStart==0){<span class="comment">//black queenside</span>
 655                         castlingRights[3]=<span class="literal">false</span>;
 656                     }<span class="literal">else</span> <span class="literal">if</span>(xStart==7){<span class="comment">//black kingside</span>
 657                         castlingRights[2]=<span class="literal">false</span>;
 658                     }
 659                 }<span class="literal">else</span> <span class="literal">if</span>(yStart==7){
 660                     <span class="literal">if</span>(xStart==0){<span class="comment">//white queenside</span>
 661                         castlingRights[1]=<span class="literal">false</span>;
 662                     }<span class="literal">else</span> <span class="literal">if</span>(xStart==7){<span class="comment">//white kingside</span>
 663                         castlingRights[0]=<span class="literal">false</span>;
 664                     }
 665                 }
 666                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 667                 legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));<span class="comment">//returns move</span>
 668                 <span class="literal">return</span> legalBoard;
 669             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 670                 getCastlingRightsAfterCapture(yFinal, xFinal, castlingRights);<span class="comment">//updates castling rights where appropriate</span>
 671                 fullMoveNo++;<span class="comment">//increments moves as black has moved</span>
 672                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 673                 <span class="comment">//simply replaces moves queen to square</span>
 674                 boardNew[yStart][xStart]=ChessBoardState.EMPTY_VALUE;boardNew[yFinal][xFinal]=ChessBoardState.QUEEN_VALUE*ChessBoardState.BLACK_MULTIPLIER;
 675                 <span class="comment">//checks to see if a capture has been made</span>
 676                 <span class="literal">if</span>(state.BOARD[yFinal][xFinal]!=ChessBoardState.EMPTY_VALUE){
 677                     halfMove=0;
 678                 }<span class="literal">else</span>{
 679                     halfMove++;
 680                 }
 681                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 682                 legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));<span class="comment">//returns move</span>
 683                 <span class="literal">return</span> legalBoard;
 684             <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 685                 getCastlingRightsAfterCapture(yFinal, xFinal, castlingRights);<span class="comment">//updates castling rights where appropriate</span>
 686                 fullMoveNo++;<span class="comment">//increments moves as black has moved</span>
 687                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 688                 <span class="comment">//moves king</span>
 689                 boardNew[yStart][xStart]=ChessBoardState.EMPTY_VALUE;boardNew[yFinal][xFinal]=ChessBoardState.KING_VALUE*ChessBoardState.BLACK_MULTIPLIER;
 690                 <span class="comment">//checks to see if castling is happening and updates rook as appropraite</span>
 691                 <span class="literal">if</span>(xFinal==xStart+2){<span class="comment">//kingside castling</span>
 692                     boardNew[0][5]=ChessBoardState.BLACK_MULTIPLIER*ChessBoardState.ROOK_VALUE;boardNew[0][7]=ChessBoardState.EMPTY_VALUE;
 693                 }<span class="literal">else</span> <span class="literal">if</span>(xFinal==xStart-2){<span class="comment">//queenside castling</span>
 694                     boardNew[0][3]=ChessBoardState.BLACK_MULTIPLIER*ChessBoardState.ROOK_VALUE;boardNew[0][0]=ChessBoardState.EMPTY_VALUE;
 695                 }
 696                 <span class="comment">//updates castling rights</span>
 697                 castlingRights[2]=<span class="literal">false</span>;castlingRights[3]=<span class="literal">false</span>;
 698                 legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));<span class="comment">//returns move</span>
 699                 <span class="literal">return</span> legalBoard;
 700             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 701                 legalBoard=<span class="literal">new</span> ArrayList&lt;&gt;(5);
 702                 getCastlingRightsAfterCapture(yFinal, xFinal, castlingRights);<span class="comment">//updates castling rights where appropriate</span>
 703                 halfMove=0;<span class="comment">//as pawn advance resets half move clock, half move will always be at 0 after a pawn move</span>
 704                 <span class="comment">//checks to see if pawn has moved two forward (and updates en passant rights accoridngly)</span>
 705                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];
 706                 <span class="literal">if</span>(yFinal == yStart-2){
 707                     enPassantSquare =<span class="literal">new</span> <span class="literal">int</span>[2];enPassantSquare[0]=yStart-1;enPassantSquare[1]=xStart;
 708                 }
 709                 <span class="comment">//processes pawn move</span>
 710                 <span class="comment">//processes possible pawn promotion</span>
 711                 boardNew[yStart][xStart]=ChessBoardState.EMPTY_VALUE;
 712                 <span class="literal">if</span>(yFinal==0){<span class="comment">//can create four possible boards</span>
 713                     <span class="comment">//creates queen board</span>
 714                     boardNew[0][xFinal]=ChessBoardState.QUEEN_VALUE*ChessBoardState.WHITE_MULTIPLIER;
 715                     legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));
 716                     <span class="comment">//handles bishop</span>
 717                     boardNew[0][xFinal]=ChessBoardState.ROOK_VALUE*ChessBoardState.WHITE_MULTIPLIER;
 718                     legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));
 719                     <span class="comment">//handles knight</span>
 720                     boardNew[0][xFinal]=ChessBoardState.BISHOP_VALUE*ChessBoardState.WHITE_MULTIPLIER;
 721                     legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));
 722                     <span class="comment">//handles rook</span>
 723                     boardNew[0][xFinal]=ChessBoardState.KNIGHT_VALUE*ChessBoardState.WHITE_MULTIPLIER;
 724                     legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));
 725                     <span class="literal">return</span> legalBoard;<span class="comment">//returns states</span>
 726                 }
 727                 boardNew[yFinal][xFinal]=ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER;
 728                 <span class="literal">if</span>(state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT.length==2){<span class="comment">//checks for en passant capture</span>
 729                     <span class="literal">if</span>(yFinal==state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[0]&amp;&amp;xFinal==state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[1]){
 730                         boardNew[yStart][xFinal]=ChessBoardState.EMPTY_VALUE;<span class="comment">//captures pawn via en passant</span>
 731                     }
 732                 }
 733                 legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));<span class="comment">//returns move            </span>
 734                 <span class="literal">return</span> legalBoard;
 735             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 736                 getCastlingRightsAfterCapture(yFinal, xFinal, castlingRights);<span class="comment">//updates castling rights where appropriate</span>
 737                 <span class="comment">//simply replaces moves knight to square</span>
 738                 boardNew[yStart][xStart]=ChessBoardState.EMPTY_VALUE;boardNew[yFinal][xFinal]=ChessBoardState.KNIGHT_VALUE*ChessBoardState.WHITE_MULTIPLIER;
 739                 <span class="comment">//checks to see if a capture has been made</span>
 740                 <span class="literal">if</span>(state.BOARD[yFinal][xFinal]!=ChessBoardState.EMPTY_VALUE){
 741                     halfMove=0;
 742                 }<span class="literal">else</span>{
 743                     halfMove++;
 744                 }
 745                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 746                 legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));<span class="comment">//returns move</span>
 747                 <span class="literal">return</span> legalBoard;
 748             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 749                 getCastlingRightsAfterCapture(yFinal, xFinal, castlingRights);<span class="comment">//updates castling rights where appropriate</span>
 750                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 751                 <span class="comment">//simply replaces moves bishop to square</span>
 752                 boardNew[yStart][xStart]=ChessBoardState.EMPTY_VALUE;boardNew[yFinal][xFinal]=ChessBoardState.BISHOP_VALUE*ChessBoardState.WHITE_MULTIPLIER;
 753                 <span class="comment">//checks to see if a capture has been made</span>
 754                 <span class="literal">if</span>(state.BOARD[yFinal][xFinal]!=ChessBoardState.EMPTY_VALUE){
 755                     halfMove=0;
 756                 }<span class="literal">else</span>{
 757                     halfMove++;
 758                 }
 759                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 760                 legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));<span class="comment">//returns move</span>
 761                 <span class="literal">return</span> legalBoard;
 762             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 763                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 764                 <span class="comment">//simply replaces moves rook to square</span>
 765                 boardNew[yStart][xStart]=ChessBoardState.EMPTY_VALUE;boardNew[yFinal][xFinal]=ChessBoardState.ROOK_VALUE*ChessBoardState.WHITE_MULTIPLIER;
 766                 <span class="comment">//checks to see if a capture has been made</span>
 767                 <span class="literal">if</span>(state.BOARD[yFinal][xFinal]!=ChessBoardState.EMPTY_VALUE){
 768                     halfMove=0;
 769                 }<span class="literal">else</span>{
 770                     halfMove++;
 771                 }
 772                 <span class="comment">//updates castling rights if appropriate</span>
 773                 <span class="literal">if</span>(yStart==0){
 774                     <span class="literal">if</span>(xStart==0){<span class="comment">//black queenside</span>
 775                         castlingRights[3]=<span class="literal">false</span>;
 776                     }<span class="literal">else</span> <span class="literal">if</span>(xStart==7){<span class="comment">//black kingside</span>
 777                         castlingRights[2]=<span class="literal">false</span>;
 778                     }
 779                 }<span class="literal">else</span> <span class="literal">if</span>(yStart==7){
 780                     <span class="literal">if</span>(xStart==0){<span class="comment">//white queenside</span>
 781                         castlingRights[1]=<span class="literal">false</span>;
 782                     }<span class="literal">else</span> <span class="literal">if</span>(xStart==7){<span class="comment">//white kingside</span>
 783                         castlingRights[0]=<span class="literal">false</span>;
 784                     }
 785                 }
 786                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 787                 legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));<span class="comment">//returns move</span>
 788                 <span class="literal">return</span> legalBoard;
 789             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 790                 getCastlingRightsAfterCapture(yFinal, xFinal, castlingRights);<span class="comment">//updates castling rights where appropriate</span>
 791                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 792                 <span class="comment">//simply replaces moves queen to square</span>
 793                 boardNew[yStart][xStart]=ChessBoardState.EMPTY_VALUE;boardNew[yFinal][xFinal]=ChessBoardState.QUEEN_VALUE*ChessBoardState.WHITE_MULTIPLIER;
 794                 <span class="comment">//checks to see if a capture has been made</span>
 795                 <span class="literal">if</span>(state.BOARD[yFinal][xFinal]!=ChessBoardState.EMPTY_VALUE){
 796                     halfMove=0;
 797                 }<span class="literal">else</span>{
 798                     halfMove++;
 799                 }
 800                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 801                 legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));<span class="comment">//returns move</span>
 802                 <span class="literal">return</span> legalBoard;
 803             <span class="literal">default</span>:
 804                 <span class="comment">//white king</span>
 805                 getCastlingRightsAfterCapture(yFinal, xFinal, castlingRights);<span class="comment">//updates castling rights where appropriate</span>
 806                 enPassantSquare=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//as pawn is not moved, no squares can be avaliable for en passant</span>
 807                 <span class="comment">//moves king</span>
 808                 boardNew[yStart][xStart]=ChessBoardState.EMPTY_VALUE;boardNew[yFinal][xFinal]=ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER;
 809                 <span class="comment">//checks to see if castling is happening and updates rook as appropraite</span>
 810                 <span class="literal">if</span>(xFinal==xStart+2){<span class="comment">//kingside castling</span>
 811                     boardNew[7][5]=ChessBoardState.WHITE_MULTIPLIER*ChessBoardState.ROOK_VALUE;boardNew[7][7]=ChessBoardState.EMPTY_VALUE;
 812                 }<span class="literal">else</span> <span class="literal">if</span>(xFinal==xStart-2){<span class="comment">//queenside castling</span>
 813                     boardNew[7][3]=ChessBoardState.WHITE_MULTIPLIER*ChessBoardState.ROOK_VALUE;boardNew[7][0]=ChessBoardState.EMPTY_VALUE;
 814                 }
 815                 <span class="comment">//updates castling rights</span>
 816                 castlingRights[0]=<span class="literal">false</span>;castlingRights[1]=<span class="literal">false</span>;
 817                 legalBoard.add(<span class="literal">new</span> ChessBoardState(boardNew, castlingRights,!state.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMove, enPassantSquare));<span class="comment">//returns move</span>
 818                 <span class="literal">return</span> legalBoard;
 819         }
 820     }
 821     <span class="comment">/**</span>
 822 <span class="comment">     * </span><span class="ST0">Gets</span> <span class="ST0">all</span> <span class="ST0">legal</span> <span class="ST0">board</span> <span class="ST0">states</span> <span class="ST0">from</span> <span class="ST0">the</span> <span class="ST0">input</span> <span class="ST0">current</span> <span class="ST0">board</span> <span class="ST0">state</span><span class="ST0">.</span> <span class="comment">DOES</span> <span class="comment">handle</span><span class="comment"> 50 </span><span class="comment">move</span> <span class="comment">rule</span>
 823 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">currentBoard</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span>
 824 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">An</span> <span class="comment">array</span> <span class="comment">of</span> <span class="comment">all</span> <span class="comment">legal</span> <span class="comment">board</span> <span class="comment">states</span><span class="comment">.</span> <span class="comment">If</span> <span class="comment">this</span> <span class="comment">array</span> <span class="comment">is</span> <span class="comment">of</span> <span class="comment">length</span><span class="comment"> 0, </span><span class="comment">there</span> <span class="comment">are</span> <span class="comment">no</span> <span class="comment">legal</span> <span class="comment">board</span> <span class="comment">states</span> <span class="comment">from</span> <span class="comment">this</span> <span class="comment">board</span> <span class="comment">state</span>
 825      <span class="comment">*/</span>
 826     <span class="literal">public</span> ArrayList&lt;ChessBoardState&gt; getAllLegalBoardsFromState(ChessBoardState currentBoard){
 827         ArrayList&lt;ChessBoardState&gt; allNewStates=<span class="literal">new</span> ArrayList&lt;&gt;(35);<span class="comment">//stores all legal board states resulting from current board state</span>
 828         <span class="comment">//checks for draw due to 50 move rule - players are automatically drawn</span>
 829         <span class="literal">if</span>(currentBoard.HALF_MOVE_CLOCK&gt;=100){
 830             currentBoard.setIsDrawTrue();
 831             <span class="literal">return</span> allNewStates;<span class="comment">//returns no legal moves</span>
 832         }
 833         <span class="comment">//checks for a draw due to insufficient pieces</span>
 834         <span class="comment">/*draw condition with insufficient pieces: </span>
 835 <span class="comment">        only king and king, only king-bishop and king, king-knight and king, king-bishop and bishop-king with bishops on same colour square</span>
 836 <span class="comment">        */</span>
 837         <span class="literal">int</span> noOfWhiteKnights=0;<span class="literal">int</span> noOfBlackKnights=0;<span class="literal">int</span> noOfWhiteBishops=0;<span class="literal">int</span> noOfBlackBishops=0; <span class="literal">boolean</span> isBlackBishopOnBlack=<span class="literal">false</span>;
 838         <span class="literal">int</span> noOfOtherPieces=0;<span class="comment">//stores number of pieces that are not king, bishop or knights</span>
 839         <span class="literal">boolean</span> isWhiteBishopOnBlack=<span class="literal">false</span>;<span class="literal">boolean</span> isBlackBishopOnWhite=<span class="literal">false</span>;<span class="literal">boolean</span> isWhiteBishopOnWhite=<span class="literal">false</span>;<span class="literal">boolean</span> buff;
 840         <span class="literal">for</span>(<span class="literal">int</span> y=0;y&lt;8;y++){
 841             <span class="literal">for</span>(<span class="literal">int</span> x=0;x&lt;8;x++){
 842                 <span class="literal">switch</span> (currentBoard.BOARD[y][x]) {
 843                     <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 844                         noOfWhiteKnights++;
 845                         <span class="literal">break</span>;
 846                     <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 847                         noOfBlackKnights++;
 848                         <span class="literal">break</span>;
 849                     <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 850                         noOfBlackBishops++;
 851                         buff=(y%2==0&amp;&amp;x%2==0)||(y%2==1&amp;&amp;x%2==1);<span class="comment">//calculates what colour bishop is on</span>
 852                         isBlackBishopOnWhite=buff||isBlackBishopOnWhite;
 853                         isBlackBishopOnBlack=!buff ||isBlackBishopOnBlack;
 854                         <span class="literal">break</span>;
 855                     <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 856                         noOfWhiteBishops++;
 857                         buff=(y%2==0&amp;&amp;x%2==0)||(y%2==1&amp;&amp;x%2==1);<span class="comment">//calculates what colur bishop is on</span>
 858                         isWhiteBishopOnWhite=buff||isWhiteBishopOnWhite;
 859                         isWhiteBishopOnBlack=!buff ||isWhiteBishopOnBlack;
 860                         <span class="literal">break</span>;
 861                     <span class="literal">case</span> ChessBoardState.EMPTY_VALUE:
 862                         <span class="literal">break</span>;
 863                     <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 864                             <span class="literal">break</span>;
 865                     <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 866                         <span class="literal">break</span>;
 867                     <span class="literal">default</span>:
 868                         noOfOtherPieces++;
 869                         <span class="literal">break</span>;
 870                 }
 871             }
 872         }
 873         <span class="comment">//checks for draw due to insufficient material</span>
 874         <span class="literal">if</span>(!(noOfOtherPieces&gt;0 || ((noOfBlackKnights+noOfWhiteKnights)&gt;1) || ((noOfBlackKnights+noOfWhiteKnights==1) &amp;&amp; (noOfBlackBishops+noOfWhiteBishops&gt;0)) || (noOfBlackBishops&gt;1)||(noOfWhiteBishops&gt;1)||(noOfBlackBishops==1 &amp;&amp; noOfWhiteBishops==1 &amp;&amp; ((isBlackBishopOnBlack&amp;&amp;isWhiteBishopOnWhite)||(isBlackBishopOnWhite&amp;&amp;isWhiteBishopOnBlack))))){
 875             currentBoard.setIsDrawTrue();<span class="comment">//sets game as draw</span>
 876             <span class="literal">return</span> allNewStates;<span class="comment">//returns no valid options</span>
 877         }
 878         ArrayList&lt;Integer&gt;allLegalMoves=getAllLegalMoves(currentBoard);
 879         <span class="literal">if</span>(allLegalMoves.isEmpty()){<span class="comment">//when no moves can be made, need to check whether it&#39;s checkmate or stalemate</span>
 880             <span class="literal">if</span>(isInCheck(!currentBoard.IS_BLACK_TURN_TO_PLAY_NEXT,  <span class="literal">new</span> ChessBoardState(currentBoard.BOARD, currentBoard.CASTLING_RIGHTS, !currentBoard.IS_BLACK_TURN_TO_PLAY_NEXT, currentBoard.FULL_MOVE_NUMBER, currentBoard.HALF_MOVE_CLOCK, currentBoard.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT))){
 881                 currentBoard.setIsLossTrue();<span class="comment">//checkmate</span>
 882             }<span class="literal">else</span>{
 883                 currentBoard.setIsDrawTrue();<span class="comment">//stalemate</span>
 884             }
 885             <span class="literal">return</span> allNewStates;
 886         }
 887         <span class="literal">for</span>(<span class="literal">int</span> move=0;move&lt;allLegalMoves.size();move=move+4){<span class="comment">//loops through all legal moves and generates all resulting possible board states</span>
 888             allNewStates.addAll(getAllLegalBoardsFromMove(allLegalMoves.get(move), allLegalMoves.get(move+1), allLegalMoves.get(move+2), allLegalMoves.get(move+3), currentBoard));
 889         }
 890         <span class="literal">return</span> allNewStates;
 891     }
 892     <span class="comment">/**</span>
 893 <span class="comment">     * </span><span class="ST0">Creates</span> <span class="ST0">new</span> <span class="ST0">array</span> <span class="ST0">of</span> <span class="ST0">chessboards</span><span class="ST0">.</span> <span class="comment">Note</span> <span class="comment">this</span> <span class="comment">should</span> <span class="comment">only</span> <span class="comment">be</span> <span class="comment">called</span> <span class="comment">in</span> <span class="comment">the</span> <span class="comment">getAllLegalBoardsFromState</span> <span class="comment">method</span><span class="comment">.</span>
 894 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">array</span> <span class="comment">The</span> <span class="comment">array</span>
 895 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">stateToAdd</span> <span class="comment">The</span> <span class="comment">new</span> <span class="comment">state</span>
 896 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">the</span> <span class="comment">new</span> <span class="comment">array</span>
 897      <span class="comment">*/</span>
 898     <span class="literal">private</span> <span class="literal">static</span> ChessBoardState[]addChessBoardStateToArray(ChessBoardState[]array,ChessBoardState stateToAdd){
 899         ChessBoardState newStates[]=<span class="literal">new</span> ChessBoardState[array.length+1];
 900         <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;newStates.length;i++){<span class="comment">//copies old states</span>
 901             newStates[i]=array[i];
 902         }
 903         newStates[array.length]=stateToAdd;<span class="comment">//adds new state</span>
 904         <span class="literal">return</span> newStates;
 905     }
 906     <span class="comment">/**</span>
 907 <span class="comment">     * </span><span class="ST0">Creates</span> <span class="ST0">new</span> <span class="ST0">array</span> <span class="ST0">of</span> <span class="ST0">chessboards</span><span class="ST0">.</span> <span class="comment">Note</span> <span class="comment">this</span> <span class="comment">should</span> <span class="comment">only</span> <span class="comment">be</span> <span class="comment">called</span> <span class="comment">in</span> <span class="comment">the</span> <span class="comment">getAllLegalBoardsFromState</span> <span class="comment">method</span><span class="comment">.</span>
 908 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">array</span> <span class="comment">The</span> <span class="comment">array</span>
 909 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">statesToAdd</span> <span class="comment">The</span> <span class="comment">new</span> <span class="comment">states</span>
 910 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">the</span> <span class="comment">new</span> <span class="comment">array</span>
 911      <span class="comment">*/</span>    
 912     <span class="literal">private</span> <span class="literal">static</span> ChessBoardState[]addChessBoardStateToArray(ChessBoardState[]array,ChessBoardState[]statesToAdd){
 913         ChessBoardState newStates[]=<span class="literal">new</span> ChessBoardState[array.length+statesToAdd.length];
 914         <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;array.length;i++){<span class="comment">//copies old states to array</span>
 915             newStates[i]=array[i];
 916         }
 917         <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;statesToAdd.length;i++){<span class="comment">//adds new states to array</span>
 918             newStates[i+array.length]=statesToAdd[i];
 919         }
 920         <span class="literal">return</span> newStates;
 921     }
 922     <span class="comment">/**</span>
 923 <span class="comment">     * </span><span class="ST0">Calls</span> <span class="ST0">getAllLegalMovesFromSquare</span> <span class="ST0">method</span> <span class="ST0">on</span> <span class="ST0">every</span> <span class="ST0">square</span> <span class="ST0">of</span> <span class="ST0">the</span> <span class="ST0">chess</span> <span class="ST0">board</span> <span class="ST0">and</span> <span class="ST0">returns</span> <span class="ST0">all</span> <span class="ST0">moves</span><span class="ST0">.</span> <span class="comment">Read</span> <span class="comment">documentation</span> <span class="comment">of</span> <span class="comment">that</span> <span class="comment">method</span> <span class="comment">for</span> <span class="comment">details</span> <span class="comment">on</span> <span class="comment">moves</span>
 924 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">board</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">to</span> <span class="comment">analyse</span>
 925 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">An</span> <span class="comment">ArrayList</span> <span class="comment">with</span> <span class="comment">all</span> <span class="comment">legal</span> <span class="comment">moves</span> <span class="comment">from</span> <span class="comment">the</span> <span class="comment">current</span> <span class="comment">board</span><span class="comment">.</span>
 926      <span class="comment">*/</span>
 927     <span class="literal">private</span>  ArrayList &lt;Integer&gt; getAllLegalMoves(ChessBoardState board){
 928         ArrayList&lt;Integer&gt; allMoves=<span class="literal">new</span> ArrayList&lt;&gt;(140);<span class="comment">//stores all moves in the form yStart, xStart, yEnd, xEnd</span>
 929         ArrayList&lt;Integer&gt;movesFromSquare;
 930         <span class="literal">int</span> index=-1;
 931         <span class="comment">//gets all legal moves from each square on the board</span>
 932         <span class="literal">for</span>(<span class="literal">int</span> y=0;y&lt;8;y++){
 933             <span class="literal">for</span>(<span class="literal">int</span> x=0;x&lt;8;x++){
 934                 movesFromSquare=getAllLegalMovesFromSquare(y, x, board);
 935                 <span class="literal">for</span>(<span class="literal">int</span> move=0;move&lt;movesFromSquare.size();move=move+2){
 936                     allMoves.add(++index,y);allMoves.add(++index,x);allMoves.add(++index,movesFromSquare.get(move));allMoves.add(++index,movesFromSquare.get(move+1));
 937                 }
 938             }
 939         }
 940         <span class="comment">//moves ordering is employed</span>
 941         <span class="literal">final</span> <span class="literal">int</span> SIZE=allMoves.size();
 942         <span class="literal">int</span> allMovesIndex=-1;
 943         <span class="literal">int</span> moveVal[][]=<span class="literal">new</span> <span class="literal">int</span>[SIZE][2];<span class="comment">//stores the approximate value of the move and the pointer to where it is stored - this is used to order the moves rougly in order of best to worst</span>
 944         <span class="literal">for</span>(<span class="literal">int</span> move=0;move&lt;SIZE/4;move++){
 945             allMovesIndex++;
 946             moveVal[move][1]=allMovesIndex;
 947             moveVal[move][0]=getValueOfMove(board, allMoves.get(allMovesIndex), allMoves.get(++allMovesIndex), allMoves.get(++allMovesIndex), allMoves.get(++allMovesIndex));
 948         }
 949         <span class="comment">//sorts moves by value</span>
 950         Sort.mergeSortInt(moveVal);
 951         <span class="comment">//swaps moves around so they are sorted from best to worst</span>
 952         allMovesIndex=-1;
 953         <span class="literal">for</span>(<span class="literal">int</span> move=0;move&lt;SIZE/4;move++){
 954             <span class="comment">//swaps moves so they are ordered</span>
 955             Collections.swap(allMoves,++allMovesIndex,moveVal[move][1]);
 956             Collections.swap(allMoves,++allMovesIndex,moveVal[move][1]+1);
 957             Collections.swap(allMoves,++allMovesIndex,moveVal[move][1]+2);
 958             Collections.swap(allMoves,++allMovesIndex,moveVal[move][1]+3);
 959         } 
 960         <span class="literal">return</span> allMoves;<span class="comment">//returns all legal moves</span>
 961     }
 962     <span class="comment">/**</span>
 963 <span class="comment">     * </span><span class="ST0">Estimates</span> <span class="ST0">the</span> <span class="ST0">value</span> <span class="ST0">of</span> <span class="ST0">a</span> <span class="ST0">move</span><span class="ST0">, </span><span class="ST0">in</span> <span class="ST0">order</span> <span class="ST0">to</span> <span class="ST0">rank</span> <span class="ST0">the</span> <span class="ST0">move</span> <span class="ST0">values</span>
 964 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">state</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span>
 965 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">yStart</span> <span class="comment">The</span> <span class="comment">starting</span> <span class="comment">y</span> <span class="comment">coordinate</span>
 966 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">xStart</span> <span class="comment">The</span> <span class="comment">starting</span> <span class="comment">x</span> <span class="comment">coordinate</span>
 967 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">yEnd</span> <span class="comment">The</span> <span class="comment">final</span> <span class="comment">y</span> <span class="comment">coordinate</span>
 968 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">xEnd</span> <span class="comment">The</span> <span class="comment">final</span> <span class="comment">x</span> <span class="comment">coordinate</span>
 969 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">The</span> <span class="comment">value</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">move</span>
 970      <span class="comment">*/</span>
 971     <span class="literal">private</span> <span class="literal">int</span> getValueOfMove(ChessBoardState state, <span class="literal">int</span> yStart, <span class="literal">int</span> xStart, <span class="literal">int</span> yEnd, <span class="literal">int</span> xEnd){
 972         <span class="literal">int</span> val=0;
 973         <span class="comment">//gets the move value by looking how the value of the piece changes due to it&#39;s positional change. The value aslo changes depending on whether captures are made.</span>
 974         <span class="comment">//alters value for square</span>
 975         <span class="literal">switch</span> (state.BOARD[yStart][xStart]) {
 976             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 977                 val=PAWN_POSITIONAL_WHITE[yEnd][xEnd]- PAWN_POSITIONAL_WHITE[yStart][xStart];
 978                 <span class="literal">break</span>;
 979             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 980                 val=BISHOP_POSITIONAL_WHITE[yEnd][xEnd]- BISHOP_POSITIONAL_WHITE[yStart][xStart];
 981                 <span class="literal">break</span>;
 982             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 983                 val=KNIGHT_POSITIONAL_WHITE[yEnd][xEnd]- KNIGHT_POSITIONAL_WHITE[yStart][xStart];
 984                 <span class="literal">break</span>;
 985             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 986                 val=ROOK_POSITIONAL_WHITE[yEnd][xEnd]- ROOK_POSITIONAL_WHITE[yStart][xStart];
 987                 <span class="literal">break</span>;
 988             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 989                 val=QUEEN_POSITIONAL_WHITE[yEnd][xEnd]- QUEEN_POSITIONAL_WHITE[yStart][xStart];
 990                 <span class="literal">break</span>;
 991             <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER:
 992                 val=KING_POSITIONAL_WHITE_MID[yEnd][xEnd]-KING_POSITIONAL_WHITE_MID[yStart][xStart];
 993                 <span class="literal">break</span>;
 994             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 995                 val=PAWN_POSITIONAL_BLACK[yEnd][xEnd]- PAWN_POSITIONAL_BLACK[yStart][xStart];
 996                 <span class="literal">break</span>;
 997             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.BLACK_MULTIPLIER:
 998                 val=BISHOP_POSITIONAL_BLACK[yEnd][xEnd]- BISHOP_POSITIONAL_BLACK[yStart][xStart];
 999                 <span class="literal">break</span>;
1000             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1001                 val=KNIGHT_POSITIONAL_BLACK[yEnd][xEnd]- KNIGHT_POSITIONAL_BLACK[yStart][xStart];
1002                 <span class="literal">break</span>;
1003             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1004                 val=ROOK_POSITIONAL_BLACK[yEnd][xEnd]- ROOK_POSITIONAL_BLACK[yStart][xStart];
1005                 <span class="literal">break</span>;
1006             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1007                 val=QUEEN_POSITIONAL_BLACK[yEnd][xEnd]- QUEEN_POSITIONAL_BLACK[yStart][xStart];
1008                 <span class="literal">break</span>;
1009             <span class="literal">default</span>:
1010                 val=KING_POSITIONAL_BLACK_MID[yEnd][xEnd]-KING_POSITIONAL_BLACK_MID[yStart][xStart];
1011                 <span class="literal">break</span>;
1012         }
1013         <span class="literal">switch</span> (state.BOARD[yEnd][xEnd]) {
1014             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1015                 val=val-(PAWN*ChessBoardState.WHITE_MULTIPLIER + PAWN_POSITIONAL_WHITE[yEnd][xEnd]);
1016                 <span class="literal">break</span>;
1017             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1018                 val=val-(BISHOP*ChessBoardState.WHITE_MULTIPLIER + BISHOP_POSITIONAL_WHITE[yEnd][xEnd]);
1019                 <span class="literal">break</span>;
1020             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1021                 val=val-(KNIGHT*ChessBoardState.WHITE_MULTIPLIER + KNIGHT_POSITIONAL_WHITE[yEnd][xEnd]);
1022                 <span class="literal">break</span>;
1023             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1024                 val=val-(ROOK*ChessBoardState.WHITE_MULTIPLIER + ROOK_POSITIONAL_WHITE[yEnd][xEnd]);
1025                 <span class="literal">break</span>;
1026             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1027                 val=val-(QUEEN*ChessBoardState.WHITE_MULTIPLIER + QUEEN_POSITIONAL_WHITE[yEnd][xEnd]);
1028                 <span class="literal">break</span>;
1029             <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1030                 val=val-(KING*ChessBoardState.WHITE_MULTIPLIER + KING_POSITIONAL_WHITE_MID[yEnd][xEnd]);
1031                 <span class="literal">break</span>;
1032             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1033                 val=PAWN_POSITIONAL_BLACK[yEnd][xEnd]- PAWN_POSITIONAL_BLACK[yStart][xStart];
1034                 val=val-(PAWN*ChessBoardState.BLACK_MULTIPLIER + PAWN_POSITIONAL_BLACK[yEnd][xEnd]);
1035                 <span class="literal">break</span>;
1036             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1037                 val=val-(BISHOP*ChessBoardState.BLACK_MULTIPLIER + BISHOP_POSITIONAL_BLACK[yEnd][xEnd]);
1038                 <span class="literal">break</span>;
1039             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1040                 val=val-(KNIGHT*ChessBoardState.BLACK_MULTIPLIER + KNIGHT_POSITIONAL_BLACK[yEnd][xEnd]);
1041                 <span class="literal">break</span>;
1042             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1043                 val=val-(ROOK*ChessBoardState.BLACK_MULTIPLIER + ROOK_POSITIONAL_BLACK[yEnd][xEnd]);
1044                 <span class="literal">break</span>;
1045             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1046                 val=val-(QUEEN*ChessBoardState.BLACK_MULTIPLIER + QUEEN_POSITIONAL_BLACK[yEnd][xEnd]);
1047                 <span class="literal">break</span>;
1048             <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1049                 val=val-(KING*ChessBoardState.BLACK_MULTIPLIER + KING_POSITIONAL_BLACK_MID[yEnd][xEnd]);
1050                 <span class="literal">break</span>;
1051             <span class="literal">default</span>:
1052                 <span class="literal">break</span>;
1053         }    
1054         <span class="literal">return</span> val;
1055     }
1056     <span class="comment">/**</span>
1057 <span class="comment">     * </span><span class="ST0">gets</span> <span class="ST0">the</span> <span class="ST0">value</span> <span class="ST0">of</span> <span class="ST0">a</span> <span class="ST0">piece</span> <span class="ST0">and</span> <span class="ST0">returns</span> <span class="ST0">it</span>
1058 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">PIECE</span> <span class="comment">The</span> <span class="comment">piece</span>
1059 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">The</span> <span class="comment">relative</span> <span class="comment">value</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">piece</span>
1060      <span class="comment">*/</span>
1061     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">int</span> getPieceValue(<span class="literal">final</span> <span class="literal">int</span> PIECE){
1062        <span class="comment">//gets the value of the piece</span>
1063         <span class="literal">switch</span> (PIECE) {
1064             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1065                 <span class="literal">return</span> PAWN;
1066             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1067                 <span class="literal">return</span> KNIGHT;
1068             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1069                 <span class="literal">return</span> ROOK;
1070             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1071                 <span class="literal">return</span> BISHOP;
1072             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1073                 <span class="literal">return</span> QUEEN;
1074             <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1075                 <span class="literal">return</span> KING;
1076             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1077                 <span class="literal">return</span> PAWN;
1078             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1079                 <span class="literal">return</span> KNIGHT;
1080             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1081                 <span class="literal">return</span> ROOK;
1082             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1083                 <span class="literal">return</span> BISHOP;
1084             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1085                 <span class="literal">return</span> QUEEN;
1086             <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1087                 <span class="literal">return</span> KING;
1088             <span class="literal">default</span>:
1089                 <span class="literal">return</span> 0;
1090         }
1091     }
1092     <span class="comment">/**</span>
1093 <span class="comment">     * </span><span class="ST0">Gets</span> <span class="ST0">all</span> <span class="ST0">legal</span> <span class="ST0">moves</span> <span class="ST0">that</span> <span class="ST0">can</span> <span class="ST0">be</span> <span class="ST0">made</span> <span class="ST0">from</span> <span class="ST0">the</span> <span class="ST0">square</span>
1094 <span class="comment">     * </span><span class="ST0">Notes</span><span class="ST0">: </span><span class="ST0">pawn</span> <span class="ST0">promotion</span> <span class="ST0">is</span> <span class="ST0">treated</span> <span class="ST0">as</span> <span class="ST0">moving</span> <span class="ST0">a</span> <span class="ST0">pawn</span> <span class="ST0">to</span> <span class="ST0">the</span> <span class="ST0">final</span> <span class="ST0">rank</span><span class="ST0">.</span> <span class="comment">However</span><span class="comment">, </span><span class="comment">the</span> <span class="comment">actual</span> <span class="comment">piece</span> <span class="comment">chosen</span> <span class="comment">needs</span> <span class="comment">to</span> <span class="comment">be</span> <span class="comment">handled</span><span class="comment">.</span>
1095 <span class="comment">     * </span><span class="comment">Notes</span><span class="comment">: </span><span class="comment">half</span> <span class="comment">move</span> <span class="comment">clock</span> <span class="comment">is</span> <span class="comment">NOT</span> <span class="comment">handled</span> <span class="comment">by</span> <span class="comment">this</span> <span class="comment">method</span>
1096 <span class="comment">     * </span><span class="comment">Notes</span><span class="comment">: </span><span class="comment">castling</span> <span class="comment">is</span> <span class="comment">treated</span> <span class="comment">as</span> <span class="comment">king</span> <span class="comment">moving</span> <span class="comment">two</span> <span class="comment">spaces</span> <span class="comment">to</span> <span class="comment">the</span> <span class="comment">left</span> <span class="comment">or</span> <span class="comment">right</span>
1097 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">yStartingSquare</span> <span class="comment">The</span> <span class="comment">y</span> <span class="comment">index</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">starting</span> <span class="comment">square</span>
1098 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">xStartingSquare</span> <span class="comment">The</span> <span class="comment">x</span> <span class="comment">index</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">starting</span> <span class="comment">square</span>
1099 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">board</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span> <span class="comment">to</span> <span class="comment">be</span> <span class="comment">analysed</span>
1100 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">An</span> <span class="comment">array</span> <span class="comment">list</span> <span class="comment">returning</span> <span class="comment">all</span> <span class="comment">legal</span> <span class="comment">moves</span> <span class="comment">from</span> <span class="comment">a</span> <span class="comment">square</span>
1101      <span class="comment">*/</span>
1102     <span class="literal">public</span> <span class="literal">static</span> ArrayList &lt;Integer&gt; getAllLegalMovesFromSquare(<span class="literal">int</span> yStartingSquare, <span class="literal">int</span> xStartingSquare,ChessBoardState board){
1103         <span class="comment">//checks to see if square selected is empty or a piece of the wrong colour</span>
1104         <span class="literal">int</span> xVal;
1105         <span class="literal">if</span>(board.BOARD[yStartingSquare][xStartingSquare]==ChessBoardState.EMPTY_VALUE || (board.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;board.BOARD[yStartingSquare][xStartingSquare]&gt;0)|| (!board.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;board.BOARD[yStartingSquare][xStartingSquare]&lt;0)){
1106             <span class="literal">return</span> <span class="literal">new</span> ArrayList&lt;&gt;(0);<span class="comment">//returns no legal moves</span>
1107         }
1108         ArrayList&lt;Integer&gt; moves;
1109         <span class="literal">switch</span> (board.BOARD[yStartingSquare][xStartingSquare]) {
1110             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1111             {
1112                 moves=getAllLegalMovesForPawnIgnoringCheck(yStartingSquare, xStartingSquare, board);
1113                 <span class="literal">boolean</span> castlingRights[]=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights</span>
1114                 <span class="literal">int</span>[][]newBoard;<span class="comment">//stores copy of board after move made;</span>
1115                 <span class="literal">int</span>[]enPassantRightsNew;<span class="comment">//stores possible en passant squares</span>
1116                 <span class="literal">int</span> fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//stores the full move number of the next move</span>
1117                 fullMoveNo++;
1118                 <span class="literal">int</span> halfMoveNo=0;<span class="comment">//stores half move number -will always be zero for pawn moves</span>
1119                 <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;moves.size();i=i+2){<span class="comment">//goes through all moves</span>
1120                     xVal=i+1;
1121                     <span class="literal">if</span>(moves.get(i)==yStartingSquare+2){<span class="comment">//checks for black pawn moving two squares forward</span>
1122                         enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[]{yStartingSquare+1,xStartingSquare};
1123                         newBoard=board.getCopyOfBoard();
1124                         <span class="comment">//adds move to board</span>
1125                         newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;newBoard[yStartingSquare+2][xStartingSquare]=ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER;
1126                         <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){
1127                             moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1128                             i=i-2;
1129                         }
1130                     }<span class="literal">else</span> <span class="literal">if</span>(moves.get(i)==yStartingSquare-2){<span class="comment">//checks for white pawn moving two squares forward</span>
1131                         enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[]{yStartingSquare-1,xStartingSquare};
1132                         newBoard=board.getCopyOfBoard();
1133                         <span class="comment">//adds move to board</span>
1134                         newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;newBoard[yStartingSquare-2][xStartingSquare]=ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER;
1135                         <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){
1136                             moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1137                             i=i-2;
1138                         }
1139                     }<span class="literal">else</span> <span class="literal">if</span>((moves.get(i)==yStartingSquare-1 &amp;&amp; moves.get(xVal)==xStartingSquare)||(moves.get(i)==yStartingSquare+1 &amp;&amp; moves.get(xVal)==xStartingSquare)){<span class="comment">//checks for white or black pawn moving one square forward</span>
1140                         enPassantRightsNew= <span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no en passant rights as piece is moving one square</span>
1141                         newBoard=board.getCopyOfBoard();<span class="comment">//gets copy of board</span>
1142                         <span class="comment">//adds move</span>
1143                         newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER;newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;
1144                         <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){
1145                             moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1146                             i=i-2;
1147                         }                          
1148                     }<span class="literal">else</span>{<span class="comment">//must be a diagonal capture</span>
1149                         enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[0];
1150                         <span class="literal">if</span>(board.BOARD[moves.get(i)][moves.get(xVal)]==ChessBoardState.EMPTY_VALUE){<span class="comment">//en passant capture</span>
1151                             newBoard=board.getCopyOfBoard();<span class="comment">//gets copy of board</span>
1152                             <span class="comment">//adds move</span>
1153                             newBoard[yStartingSquare][moves.get(xVal)]=ChessBoardState.EMPTY_VALUE;
1154                             newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;
1155                             newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER;
1156                             <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){
1157                                 moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1158                                 i=i-2;
1159                             }
1160                         }<span class="literal">else</span>{<span class="comment">//normal capture</span>
1161                             newBoard=board.getCopyOfBoard();<span class="comment">//gets copy of board</span>
1162                             <span class="comment">//adds move</span>
1163                             newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER;
1164                             <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){
1165                                 moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1166                                 i=i-2;
1167                             }
1168                         }
1169                     }
1170                 }
1171                 <span class="literal">return</span> moves;
1172             }
1173             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1174             {
1175                 moves=getLegalMovesForRookIgnoringCheck(yStartingSquare, xStartingSquare, board);
1176                 <span class="literal">boolean</span> castlingRights[]=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights</span>
1177                 <span class="literal">int</span>[][]newBoard;<span class="comment">//stores copy of board after move made;</span>
1178                 <span class="literal">int</span>[]enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no square will be available for en passant after rook move</span>
1179                 <span class="literal">int</span> fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//stores the full move number of the next move</span>
1180                 <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){<span class="comment">//updates move number and en passant rights</span>
1181                     fullMoveNo++;
1182                     <span class="literal">if</span>(yStartingSquare==0&amp;&amp;xStartingSquare==0){
1183                         castlingRights[1]=<span class="literal">false</span>;
1184                     }<span class="literal">else</span> <span class="literal">if</span>(yStartingSquare==0&amp;&amp;xStartingSquare==7){
1185                         castlingRights[0]=<span class="literal">false</span>;
1186                     }
1187                 }<span class="literal">else</span>{
1188                     <span class="literal">if</span>(yStartingSquare==7&amp;&amp;xStartingSquare==0){
1189                         castlingRights[3]=<span class="literal">false</span>;
1190                     }<span class="literal">else</span> <span class="literal">if</span>(yStartingSquare==7&amp;&amp;xStartingSquare==7){
1191                         castlingRights[2]=<span class="literal">false</span>;
1192                     }
1193                 }
1194                 <span class="literal">int</span> halfMoveNo;<span class="comment">//stores half move number</span>
1195                 <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;moves.size();i=i+2){<span class="comment">//goes through all moves</span>
1196                     xVal=i+1;
1197                     <span class="comment">//generates new board</span>
1198                     newBoard=board.getCopyOfBoard();
1199                     newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.ROOK_VALUE*ChessBoardState.WHITE_MULTIPLIER;<span class="comment">//moves castle to new square</span>
1200                     halfMoveNo=board.HALF_MOVE_CLOCK+1;
1201                     newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;<span class="comment">//sets old square to empty</span>
1202                     <span class="literal">if</span>(board.BOARD[moves.get(i)][moves.get(xVal)]!=ChessBoardState.EMPTY_VALUE){<span class="comment">//checks to see if rook has captured a piece</span>
1203                         halfMoveNo=0;
1204                     }
1205                     <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){<span class="comment">//checks to make sure move does not result in own check getting in check</span>
1206                         moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1207                         i=i-2;
1208                     }
1209                 }
1210                 <span class="literal">return</span> moves;
1211             }
1212             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1213             {
1214                 moves = getAllLegalMovesForKnightIgnoringCheck(yStartingSquare, xStartingSquare, board);
1215                 <span class="literal">boolean</span> castlingRights[]=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights - this wont be changed by any knight move</span>
1216                 <span class="literal">int</span>[][]newBoard;<span class="comment">//stores copy of board after move made;</span>
1217                 <span class="literal">int</span>[]enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no square will be available for en passant after knight move</span>
1218                 <span class="literal">int</span> fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//stores the full move number of the next move</span>
1219                 <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){
1220                     fullMoveNo++;
1221                 }
1222                 <span class="literal">int</span> halfMoveNo;<span class="comment">//stores half move number</span>
1223                 <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;moves.size();i=i+2){<span class="comment">//goes through all moves</span>
1224                     xVal=i+1;
1225                     <span class="comment">//generates new board</span>
1226                     newBoard=board.getCopyOfBoard();
1227                     newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.KNIGHT_VALUE*ChessBoardState.WHITE_MULTIPLIER;<span class="comment">//moves knight to new square</span>
1228                     halfMoveNo=board.HALF_MOVE_CLOCK+1;
1229                     newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;<span class="comment">//sets old square to empty</span>
1230                     <span class="literal">if</span>(board.BOARD[moves.get(i)][moves.get(xVal)]!=ChessBoardState.EMPTY_VALUE){<span class="comment">//checks to see if knight has captured a piece</span>
1231                         halfMoveNo=0;
1232                     }
1233                     <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){<span class="comment">//checks to make sure move does not result in own check getting in check</span>
1234                         moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1235                         i=i-2;
1236                     }
1237                 }
1238                 <span class="literal">return</span> moves;
1239             }
1240             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1241             {
1242                 moves = getLegalMovesForBishopIgnoringCheck(yStartingSquare, xStartingSquare, board);
1243                 <span class="literal">boolean</span> castlingRights[]=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights - this wont be changed by any bishop move</span>
1244                 <span class="literal">int</span>[][]newBoard;<span class="comment">//stores copy of board after move made;</span>
1245                 <span class="literal">int</span>[]enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no square will be available for en passant after bishop move</span>
1246                 <span class="literal">int</span> fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//stores the full move number of the next move</span>
1247                 <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){
1248                     fullMoveNo++;
1249                 }
1250                 <span class="literal">int</span> halfMoveNo;<span class="comment">//stores half move number</span>
1251                 <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;moves.size();i=i+2){<span class="comment">//goes through all moves</span>
1252                     xVal=i+1;
1253                     <span class="comment">//generates new board</span>
1254                     newBoard=board.getCopyOfBoard();
1255                     newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.BISHOP_VALUE*ChessBoardState.WHITE_MULTIPLIER;<span class="comment">//moves bishop to new square</span>
1256                     halfMoveNo=board.HALF_MOVE_CLOCK+1;
1257                     newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;<span class="comment">//sets old square to empty</span>
1258                     <span class="literal">if</span>(board.BOARD[moves.get(i)][moves.get(xVal)]!=ChessBoardState.EMPTY_VALUE){<span class="comment">//checks to see if bishop has captured a piece</span>
1259                         halfMoveNo=0;
1260                     }
1261                     <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){<span class="comment">//checks to make sure move does not result in own check getting in check</span>
1262                         moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1263                         i=i-2;
1264                     }
1265                 }
1266                 <span class="literal">return</span> moves;
1267             }
1268             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1269             {
1270                 moves=getLegalMovesForBishopIgnoringCheck(yStartingSquare, xStartingSquare, board);
1271                 moves.addAll(getLegalMovesForRookIgnoringCheck(yStartingSquare, xStartingSquare, board));
1272                 <span class="literal">boolean</span> castlingRights[]=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights - this wont be changed by any queen move</span>
1273                 <span class="literal">int</span>[][]newBoard;<span class="comment">//stores copy of board after move made;</span>
1274                 <span class="literal">int</span>[]enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no square will be available for en passant after queen move</span>
1275                 <span class="literal">int</span> fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//stores the full move number of the next move</span>
1276                 <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){
1277                     fullMoveNo++;
1278                 }
1279                 <span class="literal">int</span> halfMoveNo;<span class="comment">//stores half move number</span>
1280                 <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;moves.size();i=i+2){<span class="comment">//goes through all moves</span>
1281                     xVal=i+1;
1282                     <span class="comment">//generates new board</span>
1283                     newBoard=board.getCopyOfBoard();
1284                     newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.QUEEN_VALUE*ChessBoardState.WHITE_MULTIPLIER;<span class="comment">//moves queen to new square</span>
1285                     halfMoveNo=board.HALF_MOVE_CLOCK+1;
1286                     newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;<span class="comment">//sets old square to empty</span>
1287                     <span class="literal">if</span>(board.BOARD[moves.get(i)][moves.get(xVal)]!=ChessBoardState.EMPTY_VALUE){<span class="comment">//checks to see if queen has captured a piece</span>
1288                         halfMoveNo=0;
1289                     }
1290                     <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){<span class="comment">//checks to make sure move does not result in own check getting in check</span>
1291                         moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1292                         i=i-2;
1293                     }
1294                 }
1295                 <span class="literal">return</span> moves;
1296             }
1297             <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1298             {<span class="comment">//king move</span>
1299                 moves=getAllLegalMovesForKingIgnoringCheck(yStartingSquare, xStartingSquare, board);
1300                 <span class="literal">boolean</span> []castlingRights;<span class="comment">//stores castling rights of new boards;</span>
1301                 <span class="literal">int</span>[][]newBoard;<span class="comment">//stores new board;</span>
1302                 <span class="literal">int</span>[]enPassantSquares;<span class="comment">//stores squares for en passant</span>
1303                 <span class="literal">int</span> fullMoveNo;<span class="comment">//stores the move number</span>
1304                 <span class="literal">int</span> halfMoveNo;<span class="comment">//stores the half move no</span>
1305                 <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;moves.size();i=i+2){<span class="comment">//loops through every move, updating the board with the move and seeing whether the move would be legal</span>
1306                     xVal=i+1;
1307                     <span class="literal">if</span>(moves.get(xVal)==xStartingSquare+2 ){<span class="comment">//checks for kingside castling</span>
1308                         <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(board.BOARD,board.CASTLING_RIGHTS,!board.IS_BLACK_TURN_TO_PLAY_NEXT,board.FULL_MOVE_NUMBER,board.HALF_MOVE_CLOCK,board.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT))==<span class="literal">true</span>){<span class="comment">//king can&#39;t castle out of check</span>
1309                             moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1310                             i=i-2;
1311                         }<span class="literal">else</span>{
1312                             <span class="comment">//checks whether king would be in check for either of the two squares moved</span>
1313                             <span class="comment">//checks for check for move one across</span>
1314                             newBoard = board.getCopyOfBoard();<span class="comment">//gets and updates board with king moving across</span>
1315                             newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;newBoard[yStartingSquare][xStartingSquare+1]=ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER;
1316                             fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//updates move number if required</span>
1317                             halfMoveNo=board.HALF_MOVE_CLOCK+1;<span class="comment">//updates half move number</span>
1318                             enPassantSquares=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no en passant square available as king has been moved</span>
1319                             castlingRights=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights</span>
1320                             <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){
1321                                 castlingRights[2]=<span class="literal">false</span>;castlingRights[3]=<span class="literal">false</span>;
1322                                 fullMoveNo++;
1323                             }<span class="literal">else</span>{
1324                                 castlingRights[0]=<span class="literal">false</span>;castlingRights[1]=<span class="literal">false</span>;
1325                             }
1326                             <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantSquares))==<span class="literal">true</span>){<span class="comment">//king can&#39;t castle through squares where he would be in check</span>
1327                                 moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1328                                 i=i-2;
1329                             }<span class="literal">else</span>{
1330                                 newBoard[yStartingSquare][xStartingSquare+1]=ChessBoardState.WHITE_MULTIPLIER*ChessBoardState.ROOK_VALUE;newBoard[yStartingSquare][7]=ChessBoardState.EMPTY_VALUE;
1331                                 newBoard[yStartingSquare][xStartingSquare+2]=ChessBoardState.WHITE_MULTIPLIER*ChessBoardState.KING_VALUE;
1332                                 <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantSquares))==<span class="literal">true</span>){
1333                                     moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1334                                     i=i-2;
1335                                 }
1336                             }
1337                         }
1338                     }<span class="literal">else</span> <span class="literal">if</span>(moves.get(xVal)==xStartingSquare-2){<span class="comment">//checks for queenside castling</span>
1339                         <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(board.BOARD,board.CASTLING_RIGHTS,!board.IS_BLACK_TURN_TO_PLAY_NEXT,board.FULL_MOVE_NUMBER,board.HALF_MOVE_CLOCK,board.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT))==<span class="literal">true</span>){<span class="comment">//king can&#39;t castle out of check</span>
1340                             moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1341                             i=i-2;
1342                         }<span class="literal">else</span>{
1343                             <span class="comment">//checks whether king would be in check for either of the two squares moved</span>
1344                             <span class="comment">//checks for check for move one across</span>
1345                             newBoard = board.getCopyOfBoard();<span class="comment">//gets and updates board with king moving across</span>
1346                             newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;newBoard[yStartingSquare][xStartingSquare-1]=ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER;
1347                             fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//updates move number if required</span>
1348                             halfMoveNo=board.HALF_MOVE_CLOCK+1;<span class="comment">//updates half move number</span>
1349                             enPassantSquares=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no en passant square available as king has been moved</span>
1350                             castlingRights=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights</span>
1351                             <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){
1352                                 castlingRights[2]=<span class="literal">false</span>;castlingRights[3]=<span class="literal">false</span>;
1353                                 fullMoveNo++;
1354                             }<span class="literal">else</span>{
1355                                 castlingRights[0]=<span class="literal">false</span>;castlingRights[1]=<span class="literal">false</span>;
1356                             }
1357                             <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantSquares))==<span class="literal">true</span>){<span class="comment">//king can&#39;t castle trhough squares where he would be in check</span>
1358                                 moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1359                                 i=i-2;
1360                             }<span class="literal">else</span>{ 
1361                                 newBoard[yStartingSquare][xStartingSquare-1]=ChessBoardState.WHITE_MULTIPLIER*ChessBoardState.ROOK_VALUE;newBoard[yStartingSquare][0]=ChessBoardState.EMPTY_VALUE;
1362                                 newBoard[yStartingSquare][xStartingSquare-2]=ChessBoardState.WHITE_MULTIPLIER*ChessBoardState.KING_VALUE;
1363                                 <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantSquares))==<span class="literal">true</span>){
1364                                     moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1365                                     i=i-2;
1366                                 }
1367                             }
1368                         }
1369                     }<span class="literal">else</span>{<span class="comment">//checks for moves where the king moves one square</span>
1370                         newBoard=board.getCopyOfBoard();
1371                         <span class="comment">//creates a new board where king has been moved</span>
1372                         newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER;
1373                         castlingRights=board.getCopyOfCastlingRights();
1374                         fullMoveNo=board.FULL_MOVE_NUMBER;
1375                         halfMoveNo=board.HALF_MOVE_CLOCK+1;
1376                         <span class="literal">if</span>(board.BOARD[moves.get(i)][moves.get(xVal)]!=ChessBoardState.EMPTY_VALUE){<span class="comment">//checks to see if king has made a capture</span>
1377                             halfMoveNo=0;
1378                         }
1379                         enPassantSquares = <span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no en passant rights as move is made by king</span>
1380                         <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){
1381                             fullMoveNo++;
1382                             castlingRights[2]=<span class="literal">false</span>;castlingRights[3]=<span class="literal">false</span>;
1383                         }<span class="literal">else</span>{
1384                             castlingRights[0]=<span class="literal">false</span>;castlingRights[1]=<span class="literal">false</span>;
1385                         }
1386                         <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT,<span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantSquares))==<span class="literal">true</span>){
1387                             moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1388                             i=i-2;
1389                         }
1390                     }
1391                 }
1392                 <span class="literal">return</span> moves;<span class="comment">//returns legal moves</span>
1393             }
1394             <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1395             {
1396                 moves=getAllLegalMovesForPawnIgnoringCheck(yStartingSquare, xStartingSquare, board);
1397                 <span class="literal">boolean</span> castlingRights[]=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights</span>
1398                 <span class="literal">int</span>[][]newBoard;<span class="comment">//stores copy of board after move made;</span>
1399                 <span class="literal">int</span>[]enPassantRightsNew;<span class="comment">//stores possible en passant squares</span>
1400                 <span class="literal">int</span> fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//stores the full move number of the next move</span>
1401                 <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){<span class="comment">//updates move number and en passant rights</span>
1402                     fullMoveNo++;
1403                 }
1404                 <span class="literal">int</span> halfMoveNo=0;<span class="comment">//stores half move number -will always be zero for pawn moves</span>
1405                 <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;moves.size();i=i+2){<span class="comment">//goes through all moves</span>
1406                     xVal=i+1;
1407                     <span class="literal">if</span>(moves.get(i)==yStartingSquare+2){<span class="comment">//checks for black pawn moving two squares forward</span>
1408                         enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[]{yStartingSquare+1,xStartingSquare};
1409                         newBoard=board.getCopyOfBoard();
1410                         <span class="comment">//adds move to board</span>
1411                         newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;newBoard[yStartingSquare+2][xStartingSquare]=ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER;
1412                         <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){
1413                             moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1414                             i=i-2;
1415                         }
1416                     }<span class="literal">else</span> <span class="literal">if</span>(moves.get(i)==yStartingSquare-2){<span class="comment">//checks for white pawn moving two squares forward</span>
1417                         enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[]{yStartingSquare-1,xStartingSquare};
1418                         newBoard=board.getCopyOfBoard();
1419                         <span class="comment">//adds move to board</span>
1420                         newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;newBoard[yStartingSquare-2][xStartingSquare]=ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER;
1421                         <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){
1422                             moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1423                             i=i-2;
1424                         }
1425                     }<span class="literal">else</span> <span class="literal">if</span>((moves.get(i)==yStartingSquare-1 &amp;&amp; moves.get(xVal)==xStartingSquare)||(moves.get(i)==yStartingSquare+1 &amp;&amp; moves.get(xVal)==xStartingSquare)){<span class="comment">//checks for white or black pawn moving one square forward</span>
1426                         enPassantRightsNew= <span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no en passant rights as piece is moving one square</span>
1427                         newBoard=board.getCopyOfBoard();<span class="comment">//gets copy of board</span>
1428                         <span class="comment">//adds move</span>
1429                         newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER;newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;
1430                         <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){
1431                             moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1432                             i=i-2;
1433                         }
1434                     }<span class="literal">else</span>{<span class="comment">//must be a diagonal capture</span>
1435                         enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[0];
1436                         <span class="literal">if</span>(board.BOARD[moves.get(i)][moves.get(xVal)]==ChessBoardState.EMPTY_VALUE){<span class="comment">//en passant capture</span>
1437                             newBoard=board.getCopyOfBoard();<span class="comment">//gets copy of board</span>
1438                             <span class="comment">//adds move</span>
1439                             newBoard[yStartingSquare][moves.get(xVal)]=ChessBoardState.EMPTY_VALUE;
1440                             newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;
1441                             newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER;
1442                             <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){
1443                                 moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1444                                 i=i-2;
1445                             }
1446                         }<span class="literal">else</span>{<span class="comment">//normal capture</span>
1447                             newBoard=board.getCopyOfBoard();<span class="comment">//gets copy of board</span>
1448                             <span class="comment">//adds move</span>
1449                             newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER;
1450                             <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){
1451                                 moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1452                                 i=i-2;
1453                             }
1454                         }
1455                     }
1456                 }
1457                 <span class="literal">return</span> moves;
1458             }
1459             <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1460             {
1461                 moves=getLegalMovesForRookIgnoringCheck(yStartingSquare, xStartingSquare, board);
1462                 <span class="literal">boolean</span> castlingRights[]=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights</span>
1463                 <span class="literal">int</span>[][]newBoard;<span class="comment">//stores copy of board after move made;</span>
1464                 <span class="literal">int</span>[]enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no square will be available for en passant after rook move</span>
1465                 <span class="literal">int</span> fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//stores the full move number of the next move</span>
1466                 <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){<span class="comment">//updates move number and en passant rights</span>
1467                     fullMoveNo++;
1468                     <span class="literal">if</span>(yStartingSquare==0&amp;&amp;xStartingSquare==0){
1469                         castlingRights[1]=<span class="literal">false</span>;
1470                     }<span class="literal">else</span> <span class="literal">if</span>(yStartingSquare==0&amp;&amp;xStartingSquare==7){
1471                         castlingRights[0]=<span class="literal">false</span>;
1472                     }
1473                 }<span class="literal">else</span>{
1474                     <span class="literal">if</span>(yStartingSquare==7&amp;&amp;xStartingSquare==0){
1475                         castlingRights[3]=<span class="literal">false</span>;
1476                     }<span class="literal">else</span> <span class="literal">if</span>(yStartingSquare==7&amp;&amp;xStartingSquare==7){
1477                         castlingRights[2]=<span class="literal">false</span>;
1478                     }
1479                 }
1480                 <span class="literal">int</span> halfMoveNo;<span class="comment">//stores half move number</span>
1481                 <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;moves.size();i=i+2){<span class="comment">//goes through all moves</span>
1482                     xVal=i+1;
1483                     <span class="comment">//generates new board</span>
1484                     newBoard=board.getCopyOfBoard();
1485                     newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.ROOK_VALUE*ChessBoardState.BLACK_MULTIPLIER;<span class="comment">//moves castle to new square</span>
1486                     halfMoveNo=board.HALF_MOVE_CLOCK+1;
1487                     newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;<span class="comment">//sets old square to empty</span>
1488                     <span class="literal">if</span>(board.BOARD[moves.get(i)][moves.get(xVal)]!=ChessBoardState.EMPTY_VALUE){<span class="comment">//checks to see if rook has captured a piece</span>
1489                         halfMoveNo=0;
1490                     }
1491                     <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){<span class="comment">//checks to make sure move does not result in own check getting in check</span>
1492                         moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1493                         i=i-2;
1494                     }
1495                 }
1496                 <span class="literal">return</span> moves;
1497             }
1498             <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1499             {
1500                 moves = getAllLegalMovesForKnightIgnoringCheck(yStartingSquare, xStartingSquare, board);
1501                 <span class="literal">boolean</span> castlingRights[]=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights - this wont be changed by any knight move</span>
1502                 <span class="literal">int</span>[][]newBoard;<span class="comment">//stores copy of board after move made;</span>
1503                 <span class="literal">int</span>[]enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no square will be available for en passant after knight move</span>
1504                 <span class="literal">int</span> fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//stores the full move number of the next move</span>
1505                 <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){
1506                     fullMoveNo++;
1507                 }
1508                 <span class="literal">int</span> halfMoveNo;<span class="comment">//stores half move number</span>
1509                 <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;moves.size();i=i+2){<span class="comment">//goes through all moves</span>
1510                     xVal=i+1;
1511                     <span class="comment">//generates new board</span>
1512                     newBoard=board.getCopyOfBoard();
1513                     newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.KNIGHT_VALUE*ChessBoardState.BLACK_MULTIPLIER;<span class="comment">//moves knight to new square</span>
1514                     halfMoveNo=board.HALF_MOVE_CLOCK+1;
1515                     newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;<span class="comment">//sets old square to empty</span>
1516                     <span class="literal">if</span>(board.BOARD[moves.get(i)][moves.get(xVal)]!=ChessBoardState.EMPTY_VALUE){<span class="comment">//checks to see if knight has captured a piece</span>
1517                         halfMoveNo=0;
1518                     }
1519                     <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){<span class="comment">//checks to make sure move does not result in own check getting in check</span>
1520                         moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1521                         i=i-2;
1522                     }
1523                 }
1524                 <span class="literal">return</span> moves;
1525             }
1526             <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1527             {
1528                 moves = getLegalMovesForBishopIgnoringCheck(yStartingSquare, xStartingSquare, board);
1529                 <span class="literal">boolean</span> castlingRights[]=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights - this wont be changed by any bishop move</span>
1530                 <span class="literal">int</span>[][]newBoard;<span class="comment">//stores copy of board after move made;</span>
1531                 <span class="literal">int</span>[]enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no square will be available for en passant after bishop move</span>
1532                 <span class="literal">int</span> fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//stores the full move number of the next move</span>
1533                 <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){
1534                     fullMoveNo++;
1535                 }
1536                 <span class="literal">int</span> halfMoveNo;<span class="comment">//stores half move number</span>
1537                 <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;moves.size();i=i+2){<span class="comment">//goes through all moves</span>
1538                     xVal=i+1;
1539                     <span class="comment">//generates new board</span>
1540                     newBoard=board.getCopyOfBoard();
1541                     newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.BISHOP_VALUE*ChessBoardState.BLACK_MULTIPLIER;<span class="comment">//moves bishop to new square</span>
1542                     halfMoveNo=board.HALF_MOVE_CLOCK+1;
1543                     newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;<span class="comment">//sets old square to empty</span>
1544                     <span class="literal">if</span>(board.BOARD[moves.get(i)][moves.get(xVal)]!=ChessBoardState.EMPTY_VALUE){<span class="comment">//checks to see if bishop has captured a piece</span>
1545                         halfMoveNo=0;
1546                     }
1547                     <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){<span class="comment">//checks to make sure move does not result in own check getting in check</span>
1548                         moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1549                         i=i-2;
1550                     }
1551                 }
1552                 <span class="literal">return</span> moves;
1553             }
1554             <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1555             {
1556                 moves=getLegalMovesForBishopIgnoringCheck(yStartingSquare, xStartingSquare, board);
1557                 moves.addAll(getLegalMovesForRookIgnoringCheck(yStartingSquare, xStartingSquare, board));
1558                 <span class="literal">boolean</span> castlingRights[]=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights - this wont be changed by any queen move</span>
1559                 <span class="literal">int</span>[][]newBoard;<span class="comment">//stores copy of board after move made;</span>
1560                 <span class="literal">int</span>[]enPassantRightsNew=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no square will be available for en passant after queen move</span>
1561                 <span class="literal">int</span> fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//stores the full move number of the next move</span>
1562                 <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){
1563                     fullMoveNo++;
1564                 }
1565                 <span class="literal">int</span> halfMoveNo;<span class="comment">//stores half move number</span>
1566                 <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;moves.size();i=i+2){<span class="comment">//goes through all moves</span>
1567                     xVal=i+1;
1568                     <span class="comment">//generates new board</span>
1569                     newBoard=board.getCopyOfBoard();
1570                     newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.QUEEN_VALUE*ChessBoardState.BLACK_MULTIPLIER;<span class="comment">//moves queen to new square</span>
1571                     halfMoveNo=board.HALF_MOVE_CLOCK+1;
1572                     newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;<span class="comment">//sets old square to empty</span>
1573                     <span class="literal">if</span>(board.BOARD[moves.get(i)][moves.get(xVal)]!=ChessBoardState.EMPTY_VALUE){<span class="comment">//checks to see if queen has captured a piece</span>
1574                         halfMoveNo=0;
1575                     }
1576                     <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantRightsNew))==<span class="literal">true</span>){<span class="comment">//checks to make sure move does not result in own check getting in check</span>
1577                         moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1578                         i=i-2;
1579                     }
1580                 }
1581                 <span class="literal">return</span> moves;
1582             }
1583             <span class="literal">default</span>:
1584             {<span class="comment">//king move</span>
1585                 moves=getAllLegalMovesForKingIgnoringCheck(yStartingSquare, xStartingSquare, board);
1586                 <span class="literal">boolean</span> []castlingRights;<span class="comment">//stores castling rights of new boards;</span>
1587                 <span class="literal">int</span>[][]newBoard;<span class="comment">//stores new board;</span>
1588                 <span class="literal">int</span>[]enPassantSquares;<span class="comment">//stores squares for en passant</span>
1589                 <span class="literal">int</span> fullMoveNo;<span class="comment">//stores the move number</span>
1590                 <span class="literal">int</span> halfMoveNo;<span class="comment">//stores the half move no</span>
1591                 <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;moves.size();i=i+2){<span class="comment">//loops through every move, updating the board with the move and seeing whether the move would be legal</span>
1592                     xVal=i+1;
1593                     <span class="literal">if</span>(moves.get(xVal)==xStartingSquare+2 ){<span class="comment">//checks for kingside castling</span>
1594                         <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(board.BOARD,board.CASTLING_RIGHTS,!board.IS_BLACK_TURN_TO_PLAY_NEXT,board.FULL_MOVE_NUMBER,board.HALF_MOVE_CLOCK,board.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT))==<span class="literal">true</span>){<span class="comment">//king can&#39;t castle out of check</span>
1595                             moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1596                             i=i-2;
1597                         }<span class="literal">else</span>{
1598                             <span class="comment">//checks whether king would be in check for either of the two squares moved</span>
1599                             <span class="comment">//checks for check for move one across</span>
1600                             newBoard = board.getCopyOfBoard();<span class="comment">//gets and updates board with king moving across</span>
1601                             newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;newBoard[yStartingSquare][xStartingSquare+1]=ChessBoardState.KING_VALUE*ChessBoardState.BLACK_MULTIPLIER;
1602                             fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//updates move number if required</span>
1603                             halfMoveNo=board.HALF_MOVE_CLOCK+1;<span class="comment">//updates half move number</span>
1604                             enPassantSquares=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no en passant square available as king has been moved</span>
1605                             castlingRights=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights</span>
1606                             <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){
1607                                 castlingRights[2]=<span class="literal">false</span>;castlingRights[3]=<span class="literal">false</span>;
1608                                 fullMoveNo++;
1609                             }<span class="literal">else</span>{
1610                                 castlingRights[0]=<span class="literal">false</span>;castlingRights[1]=<span class="literal">false</span>;
1611                             }
1612                             <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantSquares))==<span class="literal">true</span>){<span class="comment">//king can&#39;t castle through squares where he would be in check</span>
1613                                 moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1614                                 i=i-2;
1615                             }<span class="literal">else</span>{
1616                                 newBoard[yStartingSquare][xStartingSquare+1]=ChessBoardState.BLACK_MULTIPLIER*ChessBoardState.ROOK_VALUE;newBoard[yStartingSquare][7]=ChessBoardState.EMPTY_VALUE;
1617                                 newBoard[yStartingSquare][xStartingSquare+2]=ChessBoardState.BLACK_MULTIPLIER*ChessBoardState.KING_VALUE;
1618                                 <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantSquares))==<span class="literal">true</span>){
1619                                     moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1620                                     i=i-2;
1621                                 }
1622                             }
1623                         }
1624                     }<span class="literal">else</span> <span class="literal">if</span>(moves.get(xVal)==xStartingSquare-2){<span class="comment">//checks for queenside castling</span>
1625                         <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(board.BOARD,board.CASTLING_RIGHTS,!board.IS_BLACK_TURN_TO_PLAY_NEXT,board.FULL_MOVE_NUMBER,board.HALF_MOVE_CLOCK,board.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT))==<span class="literal">true</span>){<span class="comment">//king can&#39;t castle out of check</span>
1626                             moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1627                             i=i-2;
1628                         }<span class="literal">else</span>{
1629                             <span class="comment">//checks whether king would be in check for either of the two squares moved</span>
1630                             <span class="comment">//checks for check for move one across</span>
1631                             newBoard = board.getCopyOfBoard();<span class="comment">//gets and updates board with king moving across</span>
1632                             newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;newBoard[yStartingSquare][xStartingSquare-1]=ChessBoardState.KING_VALUE*ChessBoardState.BLACK_MULTIPLIER;
1633                             fullMoveNo=board.FULL_MOVE_NUMBER;<span class="comment">//updates move number if required</span>
1634                             halfMoveNo=board.HALF_MOVE_CLOCK+1;<span class="comment">//updates half move number</span>
1635                             enPassantSquares=<span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no en passant square available as king has been moved</span>
1636                             castlingRights=board.getCopyOfCastlingRights();<span class="comment">//stores castling rights</span>
1637                             <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){
1638                                 castlingRights[2]=<span class="literal">false</span>;castlingRights[3]=<span class="literal">false</span>;
1639                                 fullMoveNo++;
1640                             }<span class="literal">else</span>{
1641                                 castlingRights[0]=<span class="literal">false</span>;castlingRights[1]=<span class="literal">false</span>;
1642                             }
1643                             <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantSquares))==<span class="literal">true</span>){<span class="comment">//king can&#39;t castle trhough squares where he would be in check</span>
1644                                 moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1645                                 i=i-2;
1646                             }<span class="literal">else</span>{ 
1647                                 newBoard[yStartingSquare][xStartingSquare-1]=ChessBoardState.BLACK_MULTIPLIER*ChessBoardState.ROOK_VALUE;newBoard[yStartingSquare][0]=ChessBoardState.EMPTY_VALUE;
1648                                 newBoard[yStartingSquare][xStartingSquare-2]=ChessBoardState.BLACK_MULTIPLIER*ChessBoardState.KING_VALUE;
1649                                 <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT, <span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantSquares))==<span class="literal">true</span>){
1650                                     moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1651                                     i=i-2;
1652                                 }
1653                             }
1654                         }
1655                     }<span class="literal">else</span>{<span class="comment">//checks for moves where the king moves one square</span>
1656                         newBoard=board.getCopyOfBoard();
1657                         <span class="comment">//creates a new board where king has been moved</span>
1658                         newBoard[yStartingSquare][xStartingSquare]=ChessBoardState.EMPTY_VALUE;newBoard[moves.get(i)][moves.get(xVal)]=ChessBoardState.KING_VALUE*ChessBoardState.BLACK_MULTIPLIER;
1659                         castlingRights=board.getCopyOfCastlingRights();
1660                         fullMoveNo=board.FULL_MOVE_NUMBER;
1661                         halfMoveNo=board.HALF_MOVE_CLOCK+1;
1662                         <span class="literal">if</span>(board.BOARD[moves.get(i)][moves.get(xVal)]!=ChessBoardState.EMPTY_VALUE){<span class="comment">//checks to see if king has made a capture</span>
1663                             halfMoveNo=0;
1664                         }
1665                         enPassantSquares = <span class="literal">new</span> <span class="literal">int</span>[0];<span class="comment">//no en passant rights as move is made by king</span>
1666                         <span class="literal">if</span>(board.IS_BLACK_TURN_TO_PLAY_NEXT){
1667                             fullMoveNo++;
1668                             castlingRights[2]=<span class="literal">false</span>;castlingRights[3]=<span class="literal">false</span>;
1669                         }<span class="literal">else</span>{
1670                             castlingRights[0]=<span class="literal">false</span>;castlingRights[1]=<span class="literal">false</span>;
1671                         }
1672                         <span class="literal">if</span>(isInCheck(!board.IS_BLACK_TURN_TO_PLAY_NEXT,<span class="literal">new</span> ChessBoardState(newBoard, castlingRights, !board.IS_BLACK_TURN_TO_PLAY_NEXT, fullMoveNo, halfMoveNo, enPassantSquares))==<span class="literal">true</span>){
1673                             moves.remove(i);moves.remove(i);<span class="comment">//removes invalid board states from list</span>
1674                             i=i-2;
1675                         }
1676                     }
1677                 }
1678                 <span class="literal">return</span> moves;<span class="comment">//returns legal moves</span>
1679             }
1680         }
1681     }
1682     <span class="comment">/**</span>
1683 <span class="comment">     * </span><span class="ST0">Checks</span> <span class="ST0">to</span> <span class="ST0">see</span> <span class="ST0">if</span> <span class="ST0">king</span> <span class="ST0">of</span> <span class="ST0">input</span> <span class="ST0">colour</span> <span class="ST0">is</span> <span class="ST0">in</span> <span class="ST0">check</span> <span class="ST0">in</span> <span class="ST0">the</span> <span class="ST0">current</span> <span class="ST0">state</span><span class="ST0">.</span> <span class="comment">This</span> <span class="comment">method</span> <span class="comment">is</span> <span class="comment">used</span> <span class="comment">as</span> <span class="comment">part</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">process</span> <span class="comment">to</span> <span class="comment">obtain</span> <span class="comment">all</span> <span class="comment">legal</span> <span class="comment">moves</span><span class="comment">.</span>
1684 <span class="comment">     * </span><span class="comment">Must</span> <span class="comment">be</span> <span class="comment">called</span> <span class="comment">on</span> <span class="comment">the</span> <span class="comment">correct</span> <span class="comment">king</span> <span class="comment">given</span> <span class="comment">who</span> <span class="comment">is</span> <span class="comment">about</span> <span class="comment">to</span> <span class="comment">move</span><span class="comment">.</span>
1685 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">isKingWhite</span> <span class="comment">The</span> <span class="comment">colour</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">king</span> <span class="comment">to</span> <span class="comment">check</span>
1686 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">state</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span> <span class="comment">to</span> <span class="comment">check</span>
1687 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">True</span> <span class="comment">is</span> <span class="comment">returned</span> <span class="comment">if</span> <span class="comment">the</span> <span class="comment">king</span> <span class="comment">chosen</span> <span class="comment">is</span> <span class="comment">in</span> <span class="comment">check</span> <span class="comment">and</span> <span class="comment">false</span> <span class="comment">is</span> <span class="comment">returned</span> <span class="comment">otherwise</span>
1688      <span class="comment">*/</span>
1689     <span class="literal">public</span> <span class="literal">static</span> <span class="literal">boolean</span> isInCheck (<span class="literal">boolean</span> isKingWhite,ChessBoardState state){
1690         <span class="comment">//checks to see whether the king square is being targeted by pieces of the opposing colour</span>
1691         <span class="literal">int</span> yCoordKing=-1;<span class="literal">int</span> xCoordKing=-1;<span class="comment">//stores the coordinate of the king</span>
1692         ArrayList&lt;Integer&gt; allAvailableMoves=<span class="literal">new</span> ArrayList&lt;&gt;(70);<span class="comment">//stores any array list storing all legal moves</span>
1693         <span class="comment">//int[][]allAvailableMoves = new int[0][2];//stores all moves that can be got from a square</span>
1694         <span class="literal">if</span>(isKingWhite){
1695             <span class="literal">for</span>(<span class="literal">int</span> y=0;y&lt;8;y++){<span class="comment">//loops through board to find king and get all available moves from other colour</span>
1696                 <span class="literal">for</span>(<span class="literal">int</span> x=0;x&lt;8;x++){
1697                     <span class="literal">switch</span> (state.BOARD[y][x]) {
1698                         <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1699                             allAvailableMoves.addAll(getAllLegalMovesForPawnIgnoringCheck(y, x, state));
1700                             <span class="literal">break</span>;
1701                         <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1702                             allAvailableMoves.addAll(getLegalMovesForRookIgnoringCheck(y, x, state));
1703                             <span class="literal">break</span>;
1704                         <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1705                             allAvailableMoves.addAll(getAllLegalMovesForKnightIgnoringCheck(y, x, state));
1706                             <span class="literal">break</span>;
1707                         <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1708                             allAvailableMoves.addAll(getLegalMovesForBishopIgnoringCheck(y, x, state));
1709                             <span class="literal">break</span>;
1710                         <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1711                             allAvailableMoves.addAll(getLegalMovesForRookIgnoringCheck(y, x, state));allAvailableMoves.addAll(getLegalMovesForBishopIgnoringCheck(y, x, state));
1712                             <span class="literal">break</span>;
1713                         <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1714                             allAvailableMoves.addAll(getAllLegalMovesForKingIgnoringCheck(y, x, state));
1715                             <span class="literal">break</span>;
1716                         <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1717                             yCoordKing=y;
1718                             xCoordKing=x;
1719                             <span class="literal">break</span>;
1720                         <span class="literal">default</span>:
1721                             <span class="literal">break</span>;
1722                     }
1723                 }
1724             }
1725             
1726         }<span class="literal">else</span>{
1727             <span class="literal">for</span>(<span class="literal">int</span> y=0;y&lt;8;y++){<span class="comment">//loops through board to find king and get all available moves from other colour</span>
1728                 <span class="literal">for</span>(<span class="literal">int</span> x=0;x&lt;8;x++){
1729                     <span class="literal">switch</span> (state.BOARD[y][x]) {
1730                         <span class="literal">case</span> ChessBoardState.PAWN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1731                             allAvailableMoves.addAll(getAllLegalMovesForPawnIgnoringCheck(y, x, state));
1732                             <span class="literal">break</span>;
1733                         <span class="literal">case</span> ChessBoardState.ROOK_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1734                             allAvailableMoves.addAll(getLegalMovesForRookIgnoringCheck(y, x, state));
1735                             <span class="literal">break</span>;
1736                         <span class="literal">case</span> ChessBoardState.KNIGHT_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1737                             allAvailableMoves.addAll(getAllLegalMovesForKnightIgnoringCheck(y, x, state));
1738                             <span class="literal">break</span>;
1739                         <span class="literal">case</span> ChessBoardState.BISHOP_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1740                             allAvailableMoves.addAll(getLegalMovesForBishopIgnoringCheck(y, x, state));
1741                             <span class="literal">break</span>;
1742                         <span class="literal">case</span> ChessBoardState.QUEEN_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1743                             allAvailableMoves.addAll(getLegalMovesForRookIgnoringCheck(y, x, state));allAvailableMoves.addAll(getLegalMovesForBishopIgnoringCheck(y, x, state));
1744                             <span class="literal">break</span>;
1745                         <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.WHITE_MULTIPLIER:
1746                             allAvailableMoves.addAll(getAllLegalMovesForKingIgnoringCheck(y, x, state));
1747                             <span class="literal">break</span>;
1748                         <span class="literal">case</span> ChessBoardState.KING_VALUE*ChessBoardState.BLACK_MULTIPLIER:
1749                             yCoordKing=y;
1750                             xCoordKing=x;
1751                             <span class="literal">break</span>;
1752                         <span class="literal">default</span>:
1753                             <span class="literal">break</span>;
1754                     }
1755                 }
1756             }            
1757         }
1758         <span class="literal">for</span>(<span class="literal">int</span> move=0;move&lt;allAvailableMoves.size();move=move+2){<span class="comment">//loops through all moves to see if king is in check </span>
1759             <span class="literal">if</span>(allAvailableMoves.get(move)==yCoordKing &amp;&amp; allAvailableMoves.get(move+1)==xCoordKing){
1760                 <span class="literal">return</span> <span class="literal">true</span>;
1761             }
1762         }
1763         <span class="literal">return</span> <span class="literal">false</span>;
1764     }
1765     <span class="comment">/**</span>
1766 <span class="comment">     * </span><span class="ST0">Gets</span> <span class="ST0">all</span> <span class="ST0">legal</span> <span class="ST0">moves</span> <span class="ST0">for</span> <span class="ST0">king</span> <span class="ST0">in</span> <span class="ST0">square</span><span class="ST0">.</span> <span class="comment">Note</span> <span class="comment">king</span> <span class="comment">must</span> <span class="comment">be</span> <span class="comment">of</span> <span class="comment">correct</span> <span class="comment">colour</span><span class="comment">.</span> <span class="comment">Castling</span> <span class="comment">is</span> <span class="comment">represented</span> <span class="comment">as</span> <span class="comment">the</span> <span class="comment">king</span> <span class="comment">moving</span> <span class="comment">two</span> <span class="comment">squares</span> <span class="comment">to</span> <span class="comment">the</span> <span class="comment">left</span> <span class="comment">or</span> <span class="comment">right</span><span class="comment">.</span>
1767 <span class="comment">     * </span><span class="comment">NOTE</span><span class="comment">: </span><span class="comment">You</span> <span class="comment">can</span><span class="comment">&#39;</span><span class="comment">t</span> <span class="comment">castle</span> <span class="comment">out</span> <span class="comment">of</span> <span class="comment">check</span> <span class="comment">but</span> <span class="comment">as</span> <span class="comment">this</span> <span class="comment">method</span> <span class="comment">ignores</span> <span class="comment">check</span><span class="comment">, </span><span class="comment">this</span> <span class="comment">will</span> <span class="comment">need</span> <span class="comment">to</span> <span class="comment">be</span> <span class="comment">handled</span><span class="comment">.</span>
1768 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">ySquare</span> <span class="comment">The</span> <span class="comment">y</span> <span class="comment">index</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">king</span>
1769 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">xSquare</span> <span class="comment">The</span> <span class="comment">x</span> <span class="comment">index</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">king</span>
1770 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">state</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span>
1771 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">The</span> <span class="comment">moves</span>
1772      <span class="comment">*/</span>
1773     <span class="literal">private</span> <span class="literal">static</span> ArrayList &lt;Integer&gt; getAllLegalMovesForKingIgnoringCheck(<span class="literal">int</span> ySquare, <span class="literal">int</span> xSquare ,ChessBoardState state){
1774         ArrayList&lt;Integer&gt;moves = <span class="literal">new</span> ArrayList&lt;&gt;();<span class="comment">//array list storing all moves. Y then x moves are added alternatingly </span>
1775         <span class="literal">if</span>(state.IS_BLACK_TURN_TO_PLAY_NEXT){<span class="comment">//if the king is black</span>
1776             <span class="comment">//checks for move one square up</span>
1777             <span class="literal">if</span>(ySquare!=0){
1778                 <span class="literal">if</span>(state.BOARD[ySquare-1][xSquare]&gt;=0){<span class="comment">//checks if square is empty or of opposite colour</span>
1779                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare-1,xSquare});</span>
1780                     moves.add(ySquare-1);moves.add(xSquare);
1781                 }
1782             }
1783             <span class="comment">//checks for one move down</span>
1784             <span class="literal">if</span>(ySquare!=7){
1785                 <span class="literal">if</span>(state.BOARD[ySquare+1][xSquare]&gt;=0){<span class="comment">//checks if square is empty or of opposite colour</span>
1786                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare+1,xSquare});</span>
1787                     moves.add(ySquare+1);moves.add(xSquare);
1788                 }                
1789             }
1790             <span class="comment">//checks for one move to right</span>
1791             <span class="literal">if</span>(xSquare!=7){
1792                 <span class="literal">if</span>(state.BOARD[ySquare][xSquare+1]&gt;=0){<span class="comment">//checks if square is empty or of opposite colour</span>
1793                    <span class="comment">// moves=addToEndOfArray(moves, new int[]{ySquare,xSquare+1});</span>
1794                     moves.add(ySquare);moves.add(xSquare+1);
1795                 } 
1796                 <span class="literal">if</span>(ySquare!=0 &amp;&amp; state.BOARD[ySquare-1][xSquare+1]&gt;=0){<span class="comment">//checks for right and up</span>
1797                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare-1,xSquare+1});</span>
1798                     moves.add(ySquare-1);moves.add(xSquare+1);
1799                 }
1800                 <span class="literal">if</span>(ySquare!=7 &amp;&amp; state.BOARD[ySquare+1][xSquare+1]&gt;=0){<span class="comment">//checks for right and down</span>
1801                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare+1,xSquare+1});</span>
1802                     moves.add(ySquare+1);moves.add(xSquare+1);
1803                 }
1804             }
1805             <span class="comment">//checks for one move to left</span>
1806             <span class="literal">if</span>(xSquare!=0){
1807                 <span class="literal">if</span>(state.BOARD[ySquare][xSquare-1]&gt;=0){<span class="comment">//checks if square is empty or of opposite colour</span>
1808                    <span class="comment">// moves=addToEndOfArray(moves, new int[]{ySquare,xSquare-1});</span>
1809                     moves.add(ySquare);moves.add(xSquare-1);
1810                 }       
1811                 <span class="literal">if</span>(ySquare!=0 &amp;&amp; state.BOARD[ySquare-1][xSquare-1]&gt;=0){<span class="comment">//checks for left and up</span>
1812                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare-1,xSquare-1});</span>
1813                     moves.add(ySquare-1);moves.add(xSquare-1);
1814                 }
1815                 <span class="literal">if</span>(ySquare!=7 &amp;&amp; state.BOARD[ySquare+1][xSquare-1]&gt;=0){<span class="comment">//checks for left and down</span>
1816                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare+1,xSquare-1});</span>
1817                     moves.add(ySquare+1);moves.add(xSquare-1);
1818                 }
1819             }
1820             <span class="comment">//checks for kingside castling</span>
1821             <span class="literal">if</span>(state.CASTLING_RIGHTS[2]&amp;&amp;state.BOARD[0][5]==ChessBoardState.EMPTY_VALUE&amp;&amp;state.BOARD[0][6]==ChessBoardState.EMPTY_VALUE){
1822                 <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare,xSquare+2});</span>
1823                 moves.add(ySquare);moves.add(xSquare+2);
1824             }
1825             <span class="comment">//checks for queenside castling</span>
1826             <span class="literal">if</span>(state.CASTLING_RIGHTS[3]&amp;&amp;state.BOARD[0][3]==ChessBoardState.EMPTY_VALUE&amp;&amp;state.BOARD[0][2]==ChessBoardState.EMPTY_VALUE&amp;&amp;state.BOARD[0][1]==ChessBoardState.EMPTY_VALUE){
1827                 <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare,xSquare-2});</span>
1828                 moves.add(ySquare);moves.add(xSquare-2);
1829             }
1830         }<span class="literal">else</span>{<span class="comment">//if the king is white</span>
1831             <span class="comment">//checks for move one square up</span>
1832             <span class="literal">if</span>(ySquare!=0){
1833                 <span class="literal">if</span>(state.BOARD[ySquare-1][xSquare]&lt;=0){<span class="comment">//checks if square is empty or of opposite colour</span>
1834                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare-1,xSquare});</span>
1835                     moves.add(ySquare-1);moves.add(xSquare);
1836                 }
1837             }
1838             <span class="comment">//checks for one move down</span>
1839             <span class="literal">if</span>(ySquare!=7){
1840                 <span class="literal">if</span>(state.BOARD[ySquare+1][xSquare]&lt;=0){<span class="comment">//checks if square is empty or of opposite colour</span>
1841                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare+1,xSquare});</span>
1842                     moves.add(ySquare+1);moves.add(xSquare);
1843                 }                
1844             }
1845             <span class="comment">//checks for one move to right</span>
1846             <span class="literal">if</span>(xSquare!=7){
1847                 <span class="literal">if</span>(state.BOARD[ySquare][xSquare+1]&lt;=0){<span class="comment">//checks if square is empty or of opposite colour</span>
1848                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare,xSquare+1});</span>
1849                     moves.add(ySquare);moves.add(xSquare+1);
1850                 }  
1851                 <span class="literal">if</span>(ySquare!=0 &amp;&amp; state.BOARD[ySquare-1][xSquare+1]&lt;=0){<span class="comment">//checks for right and up</span>
1852                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare-1,xSquare+1});</span>
1853                     moves.add(ySquare-1);moves.add(xSquare+1);
1854                 }
1855                 <span class="literal">if</span>(ySquare!=7 &amp;&amp; state.BOARD[ySquare+1][xSquare+1]&lt;=0){<span class="comment">//checks for right and down</span>
1856                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare+1,xSquare+1});</span>
1857                     moves.add(ySquare+1);moves.add(xSquare+1);
1858                 }
1859             }
1860             <span class="comment">//checks for one move to left</span>
1861             <span class="literal">if</span>(xSquare!=0){
1862                 <span class="literal">if</span>(state.BOARD[ySquare][xSquare-1]&lt;=0){<span class="comment">//checks if square is empty or of opposite colour</span>
1863                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare,xSquare-1});</span>
1864                     moves.add(ySquare);moves.add(xSquare-1);
1865                 }    
1866                 <span class="literal">if</span>(ySquare!=0 &amp;&amp; state.BOARD[ySquare-1][xSquare-1]&lt;=0){<span class="comment">//checks for left and up</span>
1867                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare-1,xSquare-1});</span>
1868                     moves.add(ySquare-1);moves.add(xSquare-1);
1869                 }
1870                 <span class="literal">if</span>(ySquare!=7 &amp;&amp; state.BOARD[ySquare+1][xSquare-1]&lt;=0){<span class="comment">//checks for left and down</span>
1871                     <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare+1,xSquare-1});</span>
1872                     moves.add(ySquare+1);moves.add(xSquare-1);
1873                 }
1874             }
1875             <span class="comment">//checks for kingside castling</span>
1876             <span class="literal">if</span>(state.CASTLING_RIGHTS[0]&amp;&amp;state.BOARD[7][5]==ChessBoardState.EMPTY_VALUE&amp;&amp;state.BOARD[7][6]==ChessBoardState.EMPTY_VALUE){
1877                 <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare,xSquare+2});</span>
1878                 moves.add(ySquare);moves.add(xSquare+2);
1879             }
1880             <span class="comment">//checks for queenside castling</span>
1881             <span class="literal">if</span>(state.CASTLING_RIGHTS[1]&amp;&amp;state.BOARD[7][3]==ChessBoardState.EMPTY_VALUE&amp;&amp;state.BOARD[7][2]==ChessBoardState.EMPTY_VALUE&amp;&amp;state.BOARD[7][1]==ChessBoardState.EMPTY_VALUE){
1882                 <span class="comment">//moves=addToEndOfArray(moves, new int[]{ySquare,xSquare-2});</span>
1883                 moves.add(ySquare);moves.add(xSquare-2);
1884             }            
1885         }
1886         <span class="literal">return</span> moves;
1887     }
1888     <span class="comment">/**</span>
1889 <span class="comment">     * </span><span class="ST0">Gets</span> <span class="ST0">all</span> <span class="ST0">legal</span> <span class="ST0">moves</span> <span class="ST0">for</span> <span class="ST0">pawn</span> <span class="ST0">at</span> <span class="ST0">the</span> <span class="ST0">square</span> <span class="ST0">input</span><span class="ST0">.</span> <span class="comment">Note</span> <span class="comment">check</span> <span class="comment">is</span> <span class="comment">ignored</span> <span class="comment">and</span> <span class="comment">pawn</span> <span class="comment">promotion</span> <span class="comment">is</span> <span class="comment">treated</span> <span class="comment">as</span> <span class="comment">the</span> <span class="comment">pawn</span>
1890 <span class="comment">     * </span><span class="comment">sitting</span> <span class="comment">on</span> <span class="comment">the</span> <span class="comment">final</span> <span class="comment">rank</span><span class="comment">.</span> <span class="comment">En</span> <span class="comment">passant</span> <span class="comment">is</span> <span class="comment">supported</span> <span class="comment">but</span> <span class="comment">must</span> <span class="comment">be</span> <span class="comment">checked</span> <span class="comment">carefully</span><span class="comment">.</span> <span class="comment">Note</span><span class="comment">: </span><span class="comment">must</span> <span class="comment">be</span> <span class="comment">called</span> <span class="comment">on</span> <span class="comment">pawn</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">right</span> <span class="comment">colour</span> <span class="comment">given</span> <span class="comment">the</span> <span class="comment">board</span> <span class="comment">state</span>
1891 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">ySquare</span> <span class="comment">The</span> <span class="comment">y</span> <span class="comment">index</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">pawn</span>
1892 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">xSquare</span> <span class="comment">The</span> <span class="comment">x</span> <span class="comment">index</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">pawn</span>
1893 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">state</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span>
1894 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">All</span> <span class="comment">moves</span>
1895      <span class="comment">*/</span>
1896     <span class="literal">private</span> <span class="literal">static</span> ArrayList &lt;Integer&gt; getAllLegalMovesForPawnIgnoringCheck(<span class="literal">int</span> ySquare, <span class="literal">int</span> xSquare, ChessBoardState state){
1897         ArrayList&lt;Integer&gt; moves = <span class="literal">new</span> ArrayList&lt;&gt;(8);
1898         <span class="comment">//checks to see if pawn can move forward twice</span>
1899         <span class="literal">if</span>(state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;ySquare==1){<span class="comment">//checks to see if black pawn can move forward two moves</span>
1900             <span class="literal">if</span>(state.BOARD[ySquare+2][xSquare]==ChessBoardState.EMPTY_VALUE&amp;&amp; state.BOARD[ySquare+1][xSquare]==ChessBoardState.EMPTY_VALUE){
1901                 moves.add(ySquare+2);moves.add(xSquare);
1902             }
1903         }<span class="literal">else</span> <span class="literal">if</span>(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;ySquare==6){<span class="comment">//checks to see if white can move forward two</span>
1904             <span class="literal">if</span>(state.BOARD[ySquare-2][xSquare]==ChessBoardState.EMPTY_VALUE &amp;&amp; state.BOARD[ySquare-1][xSquare]==ChessBoardState.EMPTY_VALUE){
1905                 moves.add(ySquare-2);moves.add(xSquare);
1906             }
1907         }
1908         <span class="comment">//checks to see if pawn can move forward once</span>
1909         <span class="literal">if</span>(state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;ySquare!=7){<span class="comment">//the pawn is black</span>
1910             <span class="literal">if</span>(state.BOARD[ySquare+1][xSquare]==ChessBoardState.EMPTY_VALUE){<span class="comment">//checks to move forward once</span>
1911                 moves.add(ySquare+1);moves.add(xSquare);
1912             }
1913             <span class="literal">if</span>(xSquare!=7){<span class="comment">//checks for diagonal capture to the right as black pawn</span>
1914                 <span class="literal">if</span>(state.BOARD[ySquare+1][xSquare+1]&gt;0){<span class="comment">//checks to see if there is a white piece on the diagnoal</span>
1915                     moves.add(ySquare+1);moves.add(xSquare+1);
1916                 }
1917             }
1918             <span class="literal">if</span>(xSquare!=0){<span class="comment">//checks for left diagnoal capture</span>
1919                 <span class="literal">if</span>(state.BOARD[ySquare+1][xSquare-1]&gt;0){<span class="comment">//checks to see if white piece is on diagonal</span>
1920                     moves.add(ySquare+1);moves.add(xSquare-1);
1921                 }
1922             }
1923         }<span class="literal">else</span> <span class="literal">if</span>(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;ySquare!=0){
1924             <span class="literal">if</span>(state.BOARD[ySquare-1][xSquare]==ChessBoardState.EMPTY_VALUE){
1925                 moves.add(ySquare-1);moves.add(xSquare);
1926             }
1927             <span class="literal">if</span>(xSquare!=7){<span class="comment">//checks for diagonal capture to the right as white pawn</span>
1928                 <span class="literal">if</span>(state.BOARD[ySquare-1][xSquare+1]&lt;0){<span class="comment">//checks to see if there is a black piece on the diagnoal</span>
1929                     moves.add(ySquare-1);moves.add(xSquare+1);
1930                 }
1931             }
1932             <span class="literal">if</span>(xSquare!=0){<span class="comment">//checks for left diagnoal capture</span>
1933                 <span class="literal">if</span>(state.BOARD[ySquare-1][xSquare-1]&lt;0){<span class="comment">//checks to see if black piece is on diagonal</span>
1934                     moves.add(ySquare-1);moves.add(xSquare-1);
1935                 }
1936             }
1937         }
1938         <span class="comment">//checks for en passant captures</span>
1939         <span class="literal">if</span>(state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT.length!=0){<span class="comment">//checks for en passant</span>
1940             <span class="literal">if</span>(state.IS_BLACK_TURN_TO_PLAY_NEXT){<span class="comment">//checks for en passant captures that can be made by black pawn</span>
1941                 <span class="literal">if</span>((state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[0]==ySquare+1) &amp;&amp; ((state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[1]==xSquare-1)||(state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[1]==xSquare+1))){
1942                     moves.add(state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[0]);moves.add(state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[1]);
1943                 }
1944             }<span class="literal">else</span>{
1945                 <span class="literal">if</span>((state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[0]==ySquare-1) &amp;&amp; ((state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[1]==xSquare-1)||(state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[1]==xSquare+1))){
1946                     moves.add(state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[0]);moves.add(state.SQUARE_THAT_CAN_BE_CAPTURED_EN_PASSANT[1]);
1947                 }                
1948             }
1949         }
1950         <span class="literal">return</span> moves;
1951     }
1952     <span class="comment">/**</span>
1953 <span class="comment">     * </span><span class="ST0">Adds</span> <span class="ST0">new</span> <span class="ST0">records</span> <span class="ST0">to</span> <span class="ST0">the</span> <span class="ST0">end</span> <span class="ST0">of</span> <span class="ST0">an</span> <span class="ST0">array</span>
1954 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">currentArray</span> <span class="comment">The</span> <span class="comment">current</span> <span class="comment">array</span>
1955 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">newRecords</span> <span class="comment">The</span> <span class="comment">new</span> <span class="comment">records</span>
1956 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">arrayWidth</span> <span class="comment">The</span> <span class="comment">array</span> <span class="comment">width</span>
1957 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">The</span> <span class="comment">new</span> <span class="comment">array</span>
1958      <span class="comment">*/</span>
1959     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">int</span>[][]addToEndOfArray(<span class="literal">int</span>[][]currentArray,<span class="literal">int</span>[][]newRecords, <span class="literal">int</span> arrayWidth){
1960         <span class="literal">int</span>[][]newArray=<span class="literal">new</span> <span class="literal">int</span>[currentArray.length+newRecords.length][arrayWidth];
1961         <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;currentArray.length;i++){
1962             <span class="literal">for</span>(<span class="literal">int</span> x=0;x&lt;arrayWidth;x++){
1963                 newArray[i][x]=currentArray[i][x];
1964             }
1965         }
1966         <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;newRecords.length;i++){
1967             <span class="literal">for</span>(<span class="literal">int</span> x=0;x&lt;arrayWidth;x++){
1968                 newArray[i+currentArray.length][x]=newRecords[i][x];
1969             }
1970         }
1971         <span class="literal">return</span> newArray;
1972     }
1973     <span class="comment">/**</span>
1974 <span class="comment">     * </span><span class="ST0">Adds</span> <span class="ST0">new</span> <span class="ST0">record</span> <span class="ST0">to</span> <span class="ST0">two</span><span class="ST0"> 2</span><span class="ST0">d</span> <span class="ST0">array</span><span class="ST0">.</span> <span class="comment">This</span> <span class="comment">record</span> <span class="comment">is</span> <span class="comment">appended</span> <span class="comment">to</span> <span class="comment">the</span> <span class="comment">bottom</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">new</span> <span class="comment">array</span><span class="comment">.</span> <span class="comment">Note</span> <span class="comment">newRecord</span> <span class="comment">must</span> <span class="comment">be</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">same</span> <span class="comment">width</span> <span class="comment">as</span> <span class="comment">the</span> <span class="comment">current</span> <span class="comment">array</span>
1975 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">currentArray</span> <span class="comment">the</span> <span class="comment">array</span>
1976 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">newRecord</span> <span class="comment">the</span> <span class="comment">record</span> <span class="comment">to</span> <span class="comment">add</span>
1977 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">the</span> <span class="comment">new</span> <span class="comment">array</span>
1978      <span class="comment">*/</span>
1979     <span class="literal">private</span> <span class="literal">static</span> <span class="literal">int</span>[][] addToEndOfArray(<span class="literal">int</span>[][]currentArray,<span class="literal">int</span>[]newRecord){
1980         <span class="literal">int</span>[][]newArray=<span class="literal">new</span> <span class="literal">int</span>[currentArray.length+1][newRecord.length];<span class="comment">//creates new array one longer than last one</span>
1981         <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;newRecord.length;i++){<span class="comment">//adds new record to end of new array</span>
1982             newArray[currentArray.length][i]=newRecord[i];
1983         }
1984         <span class="literal">for</span>(<span class="literal">int</span> i=0;i&lt;currentArray.length;i++){<span class="comment">//copies old array items to new array</span>
1985             <span class="literal">for</span>(<span class="literal">int</span> x=0;x&lt;newRecord.length;x++){
1986                 newArray[i][x]=currentArray[i][x];
1987             }
1988         }
1989         <span class="literal">return</span> newArray;<span class="comment">//returns new array</span>
1990     }
1991     <span class="comment">/**</span>
1992 <span class="comment">     * </span><span class="ST0">Gets</span> <span class="ST0">all</span> <span class="ST0">legal</span> <span class="ST0">moves</span> <span class="ST0">for</span> <span class="ST0">a</span> <span class="ST0">knight</span> <span class="ST0">ignoring</span> <span class="ST0">check</span><span class="ST0">.</span> <span class="comment">Note</span> <span class="comment">knight</span> <span class="comment">in</span> <span class="comment">square</span> <span class="comment">MUST</span> <span class="comment">be</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">same</span> <span class="comment">colour</span> <span class="comment">as</span> <span class="comment">the</span> <span class="comment">colour</span> <span class="comment">that</span> <span class="comment">moves</span> <span class="comment">next</span>
1993 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">ySquare</span> <span class="comment">The</span> <span class="comment">y</span> <span class="comment">coordinate</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">knight</span>
1994 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">xSquare</span> <span class="comment">The</span> <span class="comment">x</span> <span class="comment">coordinate</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">knight</span>
1995 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">state</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span>
1996 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">All</span> <span class="comment">moves</span>
1997      <span class="comment">*/</span>
1998     <span class="literal">private</span> <span class="literal">static</span> ArrayList &lt;Integer&gt; getAllLegalMovesForKnightIgnoringCheck(<span class="literal">int</span> ySquare,<span class="literal">int</span> xSquare, ChessBoardState state){
1999         ArrayList&lt;Integer&gt;moves=<span class="literal">new</span> ArrayList&lt;&gt;();
2000         <span class="comment">/* 8 squares to check</span>
2001 <span class="comment">        y+2 x+1,y+1 x+2,y-1 x+2,y-2 x+1,y-2 x-1,y-1 x-2,y+1 x-2,y+2 x-2</span>
2002 <span class="comment">        */</span>
2003         <span class="comment">//check for y+1 and y+2 moves</span>
2004         <span class="literal">if</span>(ySquare&lt;=6){<span class="comment">//check if y+1 is a legal square</span>
2005             <span class="literal">if</span>(xSquare&lt;=5){<span class="comment">//checking for Y+1 and x+2</span>
2006                 <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare+1][xSquare+2]&gt;=0)||(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare+1][xSquare+2]&lt;=0)){
2007                     moves.add(ySquare+1);moves.add(xSquare+2);
2008                 }
2009             }
2010             <span class="literal">if</span>(xSquare&gt;=2){<span class="comment">//checking for y+1 and x-2</span>
2011                 <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare+1][xSquare-2]&gt;=0)||(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare+1][xSquare-2]&lt;=0)){
2012                     moves.add(ySquare+1);moves.add(xSquare-2);
2013                 }                
2014             }
2015             <span class="literal">if</span>(ySquare&lt;=5){<span class="comment">//checking for y+2</span>
2016                 <span class="literal">if</span>(xSquare&gt;=1){<span class="comment">//checking for Y+2 and x-1</span>
2017                     <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare+2][xSquare-1]&gt;=0)||(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare+2][xSquare-1]&lt;=0)){
2018                         moves.add(ySquare+2);moves.add(xSquare-1);
2019                     }                   
2020                 }
2021                 <span class="literal">if</span>(xSquare&lt;=6){<span class="comment">//checking for y+2 and x+1</span>
2022                     <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare+2][xSquare+1]&gt;=0)||(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare+2][xSquare+1]&lt;=0)){
2023                         moves.add(ySquare+2);moves.add(xSquare+1);
2024                     }                     
2025                 }
2026             }
2027         }
2028         <span class="literal">if</span>(ySquare&gt;=1){<span class="comment">//checking for y-1</span>
2029             <span class="literal">if</span>(xSquare&lt;=5){<span class="comment">//checking for Y-1 and x+2</span>
2030                 <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare-1][xSquare+2]&gt;=0)||(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare-1][xSquare+2]&lt;=0)){
2031                     moves.add(ySquare-1);moves.add(xSquare+2);
2032                 }               
2033             }
2034             <span class="literal">if</span>(xSquare&gt;=2){<span class="comment">//checking for y-1 and x-2</span>
2035                 <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare-1][xSquare-2]&gt;=0)||(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare-1][xSquare-2]&lt;=0)){
2036                     moves.add(ySquare-1);moves.add(xSquare-2);
2037                 }                    
2038             }
2039             <span class="literal">if</span>(ySquare&gt;=2){<span class="comment">//checking for y-2</span>
2040                 <span class="literal">if</span>(xSquare&gt;=1){<span class="comment">//checking for Y-2 and x-1</span>
2041                     <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare-2][xSquare-1]&gt;=0)||(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare-2][xSquare-1]&lt;=0)){
2042                         moves.add(ySquare-2);moves.add(xSquare-1);
2043                     }                     
2044                 }
2045                 <span class="literal">if</span>(xSquare&lt;=6){<span class="comment">//checking for y-2 and x+1</span>
2046                     <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare-2][xSquare+1]&gt;=0)||(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare-2][xSquare+1]&lt;=0)){
2047                         moves.add(ySquare-2);moves.add(xSquare+1);
2048                     }                       
2049                 }
2050             }            
2051         }
2052         <span class="literal">return</span> moves;
2053     }
2054     <span class="comment">/**</span>
2055 <span class="comment">     * </span><span class="ST0">Gets</span> <span class="ST0">all</span> <span class="ST0">legal</span> <span class="ST0">moves</span> <span class="ST0">for</span> <span class="ST0">rook</span><span class="ST0"> (</span><span class="ST0">or</span> <span class="ST0">queen</span><span class="ST0">) </span><span class="ST0">in</span> <span class="ST0">position</span><span class="ST0">, </span><span class="ST0">ignoring</span> <span class="ST0">check</span><span class="ST0">.</span> <span class="comment">This</span> <span class="comment">method</span> <span class="comment">must</span> <span class="comment">be</span> <span class="comment">called</span> <span class="comment">in</span> <span class="comment">a</span> <span class="comment">piece</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">right</span> <span class="comment">colour</span>
2056 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">ySquare</span> <span class="comment">The</span> <span class="comment">y</span> <span class="comment">coordinate</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">rook</span><span class="comment"> (</span><span class="comment">or</span> <span class="comment">queen</span><span class="comment">)</span><span class="comment">.</span>
2057 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">xSquare</span> <span class="comment">The</span> <span class="comment">x</span> <span class="comment">coordinate</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">rook</span><span class="comment"> (</span><span class="comment">or</span> <span class="comment">queen</span><span class="comment">)</span><span class="comment">.</span>
2058 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">state</span> <span class="comment">The</span> <span class="comment">board</span> <span class="comment">state</span>
2059 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">An</span> <span class="comment">ArrayList</span> <span class="comment">containing</span> <span class="comment">all</span> <span class="comment">legal</span> <span class="comment">moves</span> <span class="comment">of</span> <span class="comment">width</span><span class="comment"> 2</span><span class="comment">.</span> <span class="comment">If</span> <span class="comment">no</span> <span class="comment">moves</span> <span class="comment">are</span> <span class="comment">found</span><span class="comment">, </span><span class="comment">the</span> <span class="comment">ArrayList</span> <span class="comment">is</span> <span class="comment">of</span> <span class="comment">length</span><span class="comment"> 0</span><span class="comment">.</span>
2060      <span class="comment">*/</span>
2061     <span class="literal">private</span> <span class="literal">static</span> ArrayList &lt;Integer&gt; getLegalMovesForRookIgnoringCheck(<span class="literal">int</span> ySquare, <span class="literal">int</span> xSquare, ChessBoardState state){
2062         ArrayList&lt;Integer&gt; moves = <span class="literal">new</span> ArrayList&lt;&gt;();<span class="comment">//stores all legal moves for the rook</span>
2063         <span class="comment">//checks for moves up</span>
2064         <span class="literal">for</span>(<span class="literal">int</span> inc=1;inc&lt;=ySquare;inc++){
2065             <span class="literal">if</span>(state.BOARD[ySquare-inc][xSquare]==ChessBoardState.EMPTY_VALUE){<span class="comment">//if square is empty</span>
2066                 moves.add(ySquare-inc);moves.add(xSquare);
2067             }<span class="literal">else</span> <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare-inc][xSquare]&lt;0) || (!state.IS_BLACK_TURN_TO_PLAY_NEXT &amp;&amp; state.BOARD[ySquare-inc][xSquare]&gt;0)){<span class="comment">//if collides with piece of same colour</span>
2068                 <span class="literal">break</span>;
2069             }<span class="literal">else</span>{<span class="comment">//if collides with piece of different colours</span>
2070                 moves.add(ySquare-inc);moves.add(xSquare);
2071                 <span class="literal">break</span>;
2072             }
2073         }
2074         <span class="comment">//checks for moves down</span>
2075         <span class="literal">for</span>(<span class="literal">int</span> inc=1;inc&lt;=7-ySquare;inc++){
2076             <span class="literal">if</span>(state.BOARD[ySquare+inc][xSquare]==ChessBoardState.EMPTY_VALUE){<span class="comment">//if square is empty</span>
2077                 moves.add(ySquare+inc);moves.add(xSquare);
2078             }<span class="literal">else</span> <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare+inc][xSquare]&lt;0) || (!state.IS_BLACK_TURN_TO_PLAY_NEXT &amp;&amp; state.BOARD[ySquare+inc][xSquare]&gt;0)){<span class="comment">//if collides with piece of same colour</span>
2079                 <span class="literal">break</span>;
2080             }<span class="literal">else</span>{<span class="comment">//if collides with piece of different colours</span>
2081                 moves.add(ySquare+inc);moves.add(xSquare);
2082                 <span class="literal">break</span>;
2083             }
2084         }
2085         <span class="comment">//checks for moves to right</span>
2086         <span class="literal">for</span>(<span class="literal">int</span> inc=1;inc&lt;=7-xSquare;inc++){
2087             <span class="literal">if</span>(state.BOARD[ySquare][xSquare+inc]==ChessBoardState.EMPTY_VALUE){<span class="comment">//if square is empty</span>
2088                 moves.add(ySquare);moves.add(xSquare+inc);
2089             }<span class="literal">else</span> <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare][xSquare+inc]&lt;0) || (!state.IS_BLACK_TURN_TO_PLAY_NEXT &amp;&amp; state.BOARD[ySquare][xSquare+inc]&gt;0)){<span class="comment">//if collides with piece of same colour</span>
2090                 <span class="literal">break</span>;
2091             }<span class="literal">else</span>{<span class="comment">//if collides with piece of different colours</span>
2092                 moves.add(ySquare);moves.add(xSquare+inc);
2093                 <span class="literal">break</span>;
2094             }
2095         }
2096         <span class="comment">//checks for moves to left</span>
2097         <span class="literal">for</span>(<span class="literal">int</span> inc=1;inc&lt;=xSquare;inc++){
2098             <span class="literal">if</span>(state.BOARD[ySquare][xSquare-inc]==ChessBoardState.EMPTY_VALUE){<span class="comment">//if square is empty</span>
2099                 moves.add(ySquare);moves.add(xSquare-inc);
2100             }<span class="literal">else</span> <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare][xSquare-inc]&lt;0) || (!state.IS_BLACK_TURN_TO_PLAY_NEXT &amp;&amp; state.BOARD[ySquare][xSquare-inc]&gt;0)){<span class="comment">//if collides with piece of same colour</span>
2101                 <span class="literal">break</span>;
2102             }<span class="literal">else</span>{<span class="comment">//if collides with piece of different colours</span>
2103                 moves.add(ySquare);moves.add(xSquare-inc);
2104                 <span class="literal">break</span>;
2105             }
2106         }
2107         <span class="literal">return</span> moves;
2108     }
2109     <span class="comment">/**</span>
2110 <span class="comment">     * </span><span class="ST0">Gets</span> <span class="ST0">all</span> <span class="ST0">legal</span> <span class="ST0">moves</span> <span class="ST0">for</span> <span class="ST0">the</span> <span class="ST0">bishop</span> <span class="ST0">from</span> <span class="ST0">the</span> <span class="ST0">current</span> <span class="ST0">state</span><span class="ST0">, </span><span class="ST0">ignoring</span> <span class="ST0">whether</span> <span class="ST0">the</span> <span class="ST0">king</span> <span class="ST0">is</span> <span class="ST0">in</span> <span class="ST0">check</span><span class="ST0">.</span> <span class="comment">This</span> <span class="comment">method</span> <span class="comment">must</span> <span class="comment">be</span> <span class="comment">called</span> <span class="comment">on</span> <span class="comment">a</span> <span class="comment">bishop</span><span class="comment"> (</span><span class="comment">or</span> <span class="comment">queen</span><span class="comment">) </span><span class="comment">of</span> <span class="comment">the</span> <span class="comment">correct</span> <span class="comment">colour</span><span class="comment">.</span>
2111 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">ySquare</span> <span class="comment">The</span> <span class="comment">y</span> <span class="comment">index</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">bishop</span><span class="comment"> (</span><span class="comment">or</span> <span class="comment">queen</span><span class="comment">)</span>
2112 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">xSquare</span> <span class="comment">The</span> <span class="comment">x</span> <span class="comment">index</span> <span class="comment">of</span> <span class="comment">the</span> <span class="comment">bishop</span><span class="comment"> (</span><span class="comment">or</span> <span class="comment">queen</span><span class="comment">)</span>
2113 <span class="comment">     * </span><span class="ST0">@param</span> <span class="comment">state</span> <span class="comment">The</span> <span class="comment">chess</span> <span class="comment">board</span> <span class="comment">state</span> <span class="comment">to</span> <span class="comment">get</span> <span class="comment">the</span> <span class="comment">legal</span> <span class="comment">moves</span> <span class="comment">from</span>
2114 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">An</span> <span class="comment">ArrayList</span> <span class="comment">containing</span> <span class="comment">all</span> <span class="comment">legal</span> <span class="comment">moves</span> <span class="comment">of</span> <span class="comment">width</span><span class="comment"> 2</span><span class="comment">.</span> <span class="comment">If</span> <span class="comment">no</span> <span class="comment">moves</span> <span class="comment">are</span> <span class="comment">found</span><span class="comment">, </span><span class="comment">the</span> <span class="comment">ArrayList</span> <span class="comment">is</span> <span class="comment">of</span> <span class="comment">length</span><span class="comment"> 0</span><span class="comment">.</span>
2115      <span class="comment">*/</span>
2116     <span class="literal">private</span> <span class="literal">static</span> ArrayList &lt;Integer&gt; getLegalMovesForBishopIgnoringCheck(<span class="literal">int</span> ySquare, <span class="literal">int</span> xSquare, ChessBoardState state){
2117         ArrayList&lt;Integer&gt; moves = <span class="literal">new</span> ArrayList&lt;&gt;();
2118         <span class="comment">//check for moving down and to the right</span>
2119         <span class="literal">for</span>(<span class="literal">int</span> inc=1;inc&lt;=7-Math.max(ySquare, xSquare);inc++){
2120             <span class="literal">if</span>(state.BOARD[ySquare+inc][xSquare+inc]==ChessBoardState.EMPTY_VALUE){
2121                 moves.add(ySquare+inc);moves.add(xSquare+inc);
2122             }<span class="literal">else</span> <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare+inc][xSquare+inc]&lt;0)||(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare+inc][xSquare+inc]&gt;0)){<span class="comment">//if it collides with own piece</span>
2123                 <span class="literal">break</span>;
2124             }<span class="literal">else</span>{<span class="comment">//collides with enemy piece</span>
2125                 moves.add(ySquare+inc);moves.add(xSquare+inc);
2126                 <span class="literal">break</span>;
2127             }
2128         }
2129         <span class="comment">//checking for move down and left</span>
2130         <span class="literal">for</span>(<span class="literal">int</span> inc=1;inc&lt;=Math.min((7-ySquare),xSquare);inc++){
2131             <span class="literal">if</span>(state.BOARD[ySquare+inc][xSquare-inc]==ChessBoardState.EMPTY_VALUE){
2132                 moves.add(ySquare+inc);moves.add(xSquare-inc);
2133             }<span class="literal">else</span> <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare+inc][xSquare-inc]&lt;0)||(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare+inc][xSquare-inc]&gt;0)){<span class="comment">//if it collides with own piece</span>
2134                 <span class="literal">break</span>;
2135             }<span class="literal">else</span>{<span class="comment">//collides with enemy piece</span>
2136                moves.add(ySquare+inc);moves.add(xSquare-inc);
2137                 <span class="literal">break</span>;
2138             }
2139         }
2140         <span class="comment">//checking for move up and right</span>
2141         <span class="literal">for</span>(<span class="literal">int</span> inc=1;inc&lt;=Math.min(ySquare,(7-xSquare));inc++){
2142             <span class="literal">if</span>(state.BOARD[ySquare-inc][xSquare+inc]==ChessBoardState.EMPTY_VALUE){
2143                 moves.add(ySquare-inc);moves.add(xSquare+inc);
2144             }<span class="literal">else</span> <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare-inc][xSquare+inc]&lt;0)||(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare-inc][xSquare+inc]&gt;0)){<span class="comment">//if it collides with own piece</span>
2145                 <span class="literal">break</span>;
2146             }<span class="literal">else</span>{<span class="comment">//collides with enemy piece</span>
2147                 moves.add(ySquare-inc);moves.add(xSquare+inc);
2148                 <span class="literal">break</span>;
2149             }
2150         }
2151         <span class="comment">//checking for up and left</span>
2152         <span class="literal">for</span>(<span class="literal">int</span> inc=1;inc&lt;=Math.min(ySquare,xSquare);inc++){
2153             <span class="literal">if</span>(state.BOARD[ySquare-inc][xSquare-inc]==ChessBoardState.EMPTY_VALUE){
2154                moves.add(ySquare-inc);moves.add(xSquare-inc);
2155             }<span class="literal">else</span> <span class="literal">if</span>((state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare-inc][xSquare-inc]&lt;0)||(!state.IS_BLACK_TURN_TO_PLAY_NEXT&amp;&amp;state.BOARD[ySquare-inc][xSquare-inc]&gt;0)){<span class="comment">//if it collides with own piece</span>
2156                 <span class="literal">break</span>;
2157             }<span class="literal">else</span>{<span class="comment">//collides with enemy piece</span>
2158                 moves.add(ySquare-inc);moves.add(xSquare-inc);
2159                 <span class="literal">break</span>;
2160             }
2161         }
2162         <span class="literal">return</span> moves;
2163     }
2164     <span class="comment">/**</span>
2165 <span class="comment">     * </span><span class="ST0">Returns</span> <span class="ST0">the</span> <span class="ST0">current</span> <span class="ST0">board</span> <span class="ST0">state</span><span class="ST0">.</span>
2166 <span class="comment">     * </span><span class="ST0">@return</span> <span class="comment">The</span> <span class="comment">current</span> <span class="comment">board</span> <span class="comment">state</span>
2167      <span class="comment">*/</span>
2168     <span class="literal">public</span> ChessBoardState getCurrentState(){
2169         <span class="literal">return</span> states[states.length-1];
2170     }  
2171 }
2172 
</pre></body>
</html>
